{"version":3,"sources":["webpack:///C:/Program Files/newrelic-cli/client/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack:///C:/Program Files/newrelic-cli/client/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack:///C:/Program Files/newrelic-cli/client/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack:///C:/Program Files/newrelic-cli/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack:///C:/Program Files/newrelic-cli/client/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack:///C:/Program Files/newrelic-cli/client/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack:///C:/Program Files/newrelic-cli/client/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack:///C:/Program Files/newrelic-cli/client/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack:///./node_modules/react-router-dom/dist/index.js","webpack:///./node_modules/react-router/dist/index.js","webpack:///./node_modules/@remix-run/router/dist/router.js"],"names":["_setPrototypeOf","o","p","Object","setPrototypeOf","bind","__proto__","_inheritsLoose","subClass","superClass","prototype","create","constructor","_arrayLikeToArray","arr","len","length","i","arr2","Array","_slicedToArray","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","call","next","done","push","value","err","minLen","n","toString","slice","name","from","test","TypeError","React","injectedPackages","ReactDOM","_extends","assign","target","arguments","source","key","hasOwnProperty","apply","this","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","Set","_excluded","Map","startTransitionImpl","BrowserRouter","_ref4","basename","children","future","window","historyRef","useRef","current","v5Compat","history","state","setStateImpl","useState","action","location","v7_startTransition","setState","useCallback","newState","useLayoutEffect","listen","createElement","navigationType","navigator","isBrowser","document","ABSOLUTE_URL_REGEX","Link","forwardRef","_ref7","ref","absoluteHref","onClick","relative","reloadDocument","replace","to","preventScrollReset","unstable_viewTransition","rest","useContext","isExternal","currentUrl","URL","href","targetUrl","startsWith","protocol","path","pathname","origin","search","hash","e","internalOnClick","_temp","replaceProp","navigate","event","button","metaKey","altKey","ctrlKey","shiftKey","isModifiedEvent","shouldProcessLinkClick","preventDefault","undefined","useLinkClickHandler","defaultPrevented","DataRouterHook","DataRouterStateHook","DataRouterContext","createContext","DataRouterStateContext","NavigationContext","LocationContext","RouteContext","outlet","matches","isDataRoute","RouteErrorContext","useHref","useInRouterContext","useResolvedPath","joinedPathname","createHref","useLocation","useIsomorphicLayoutEffect","cb","static","useNavigate","router","useDataRouterContext","UseNavigateStable","id","useCurrentRouteId","activeRef","options","fromRouteId","useNavigateStable","dataRouterContext","locationPathname","routePathnamesJson","JSON","stringify","map","match","pathnameBase","go","parse","useNavigateUnstable","_temp2","useMemo","useRoutesImpl","routes","locationArg","dataRouterState","parentMatches","routeMatch","parentParams","params","parentPathnameBase","route","locationFromContext","_parsedLocationArg$pa","parsedLocationArg","remainingPathname","renderedMatches","_renderMatches","encodeLocation","Provider","Pop","DefaultErrorComponent","error","_state$errors","useDataRouterState","UseRouteError","routeId","errors","useRouteError","message","status","statusText","Error","stack","lightgrey","preStyles","padding","backgroundColor","Fragment","style","fontStyle","defaultErrorElement","RenderErrorBoundary","Component","props","super","revalidation","componentDidCatch","errorInfo","console","render","routeContext","component","RenderedRoute","_ref","staticContext","errorElement","ErrorBoundary","_deepestRenderedBoundaryId","_dataRouterState2","_dataRouterState","errorIndex","findIndex","m","Math","min","reduceRight","index","concat","getChildren","element","hookName","ctx","useRouteContext","thisRoute","useRouteId","UseRouteId","useNavigation","UseNavigation","navigation","useMatches","loaderData","UseMatches","blockerId","useBlocker","shouldBlock","UseBlocker","blockerKey","setBlockerKey","blockerFunction","arg","currentLocation","nextLocation","historyAction","useEffect","String","deleteBlocker","getBlocker","blockers","has","get","Route","_props","Router","_ref5","basenameProp","locationProp","staticProp","navigationContext","locationContext","trailingPathname","Routes","_ref6","useRoutes","createRoutesFromChildren","Promise","parentPath","Children","forEach","isValidElement","treePath","type","join","caseSensitive","loader","hasErrorBoundary","shouldRevalidate","handle","lazy","mapRouteProperties","updates","Action","PopStateEventType","createMemoryHistory","entries","initialEntries","initialIndex","entry","createMemoryLocation","clampIndex","listener","max","getCurrentLocation","createLocation","warning","charAt","createPath","createURL","parsePath","Push","splice","delta","Replace","nextIndex","fn","createBrowserHistory","getUrlBasedHistory","globalHistory","usr","createHashHistory","substr","base","querySelector","getAttribute","url","hashIndex","invariant","cond","warn","createKey","random","getHistoryState","idx","parsedPath","searchIndex","getLocation","validateLocation","defaultView","getIndex","handlePop","replaceState","addEventListener","removeEventListener","historyState","pushState","DOMException","ResultType","immutableRouteKeys","convertRoutesToDataRoutes","manifest","isIndexRoute","indexRoute","pathOrLayoutRoute","matchRoutes","stripBasename","branches","flattenRoutes","sort","a","b","score","every","compareIndexes","routesMeta","meta","childrenIndex","rankRouteBranches","matchRouteBranch","safelyDecodeURI","convertRouteMatchToUiMatch","data","parentsMeta","flattenRoute","relativePath","joinPaths","computeScore","_route$path","includes","exploded","explodeOptionalSegments","segments","split","first","isOptional","endsWith","required","restExploded","result","subpath","paramRe","isSplat","s","initialScore","some","filter","reduce","segment","branch","matchedParams","matchedPathname","end","matchPath","normalizePathname","pattern","matcher","compiledParams","regexpSource","_","paramName","RegExp","compilePath","captureGroups","memo","splatValue","decodeURIComponent","safelyDecodeURIComponent","decodeURI","toLowerCase","startIndex","nextChar","getInvalidPathError","char","field","dest","getPathContributingMatches","resolveTo","toArg","routePathnames","isPathRelative","isEmptyPath","toPathname","fromSegments","toSegments","shift","pop","routePathnameIndex","fromPathname","resolvePathname","normalizeSearch","normalizeHash","resolvePath","hasExplicitTrailingSlash","hasCurrentTrailingSlash","paths","AbortedDeferredError","ErrorResponseImpl","internal","isRouteErrorResponse","validMutationMethodsArr","validMutationMethods","validRequestMethodsArr","validRequestMethods","redirectStatusCodes","redirectPreserveMethodStatusCodes","IDLE_NAVIGATION","formMethod","formAction","formEncType","formData","json","text","IDLE_FETCHER","IDLE_BLOCKER","proceed","reset","defaultMapRouteProperties","Boolean","TRANSITIONS_STORAGE_KEY","createRouter","init","routerWindow","isServer","detectErrorBoundary","inFlightDataRoutes","dataRoutes","v7_fetcherPersist","v7_normalizeFormMethod","v7_prependBasename","unlistenHistory","subscribers","savedScrollPositions","getScrollRestorationKey","getScrollPosition","initialScrollRestored","hydrationData","initialMatches","initialErrors","getInternalRouterError","getShortCircuitMatches","pendingNavigationController","initialized","restoreScrollPosition","actionData","fetchers","pendingAction","pendingPreventScrollReset","pendingViewTransitionEnabled","appliedViewTransitions","removePageHideEventListener","isUninterruptedRevalidation","isRevalidationRequired","cancelledDeferredRoutes","cancelledFetcherLoads","fetchControllers","incrementingLoadId","pendingNavigationLoadId","fetchReloadIds","fetchRedirectIds","fetchLoadMatches","activeFetchers","deletedFetchers","activeDeferreds","blockerFunctions","ignoreNextHistoryUpdate","updateState","opts","completedFetchers","deletedFetchersKeys","fetcher","subscriber","unstable_viewTransitionOpts","viewTransitionOpts","unstable_flushSync","flushSync","delete","deleteFetcher","completeNavigation","_location$state","_location$state2","isActionReload","isMutationMethod","_isRedirect","mergeLoaderData","size","k","set","priorPaths","toPaths","add","getSavedScrollPosition","async","startNavigation","abort","startUninterruptedRevalidation","getScrollKey","saveScrollPosition","enableViewTransition","routesToUse","loadingNavigation","overrideNavigation","notFoundMatches","cancelActiveDeferreds","isHashChangeOnly","submission","AbortController","pendingActionData","pendingError","request","createClientSideRequest","signal","findNearestBoundary","actionOutput","interruptActiveLoads","getSubmittingNavigation","actionMatch","getTargetMatch","callLoaderOrAction","aborted","shortCircuited","method","isRedirectResult","startRedirectNavigation","isErrorResult","boundaryMatch","pendingActionError","isDeferredResult","handleAction","getLoadingNavigation","Request","fetcherSubmission","activeSubmission","getSubmissionFromNavigation","matchesToLoad","revalidatingFetchers","getMatchesToLoad","updatedFetchers","markFetchRedirectsDone","rf","revalidatingFetcher","getLoadingFetcher","abortFetcher","controller","abortPendingFetchRevalidations","f","results","loaderResults","fetcherResults","callLoadersAndMaybeResolveData","redirect","findRedirect","fetcherKey","processLoaderData","deferredData","subscribe","didAbortFetchLoads","abortStaleFetchLoads","shouldUpdateFetchers","handleLoaders","revalidate","redirectLocation","isDocumentReload","redirectHistoryAction","currentMatches","fetchersToLoad","all","resolveDeferredResults","updateFetcherState","setFetcherError","getFetcher","markFetchersDone","doneFetcher","getDoneFetcher","doneKeys","landedId","yeetedKeys","updateBlocker","newBlocker","blocker","shouldBlockNavigation","_ref2","predicate","cancelledRouteIds","dfd","cancel","y","initialize","_window","transitions","sessionPositions","sessionStorage","getItem","v","restoreAppliedTransitions","_saveAppliedTransitions","setItem","persistAppliedTransitions","enableScrollRestoration","positions","getPosition","getKey","normalizedPath","normalizeTo","normalizeNavigateOptions","userReplace","fetch","requestMatches","existingFetcher","getSubmittingFetcher","abortController","fetchRequest","originatingLoadId","actionResult","revalidationRequest","loadId","loadFetcher","staleKey","r","handleFetcherAction","resolveDeferredData","handleFetcherLoader","count","dispose","clear","_internalFetchControllers","_internalActiveDeferreds","_internalSetRoutes","newRoutes","prependBasename","contextualMatches","activeRouteMatch","hasNakedIndexQuery","normalizeFormMethod","isFetcher","body","isSubmissionNavigation","isValidMethod","searchParams","getInvalidBodyError","rawFormMethod","toUpperCase","stripHashFromPath","FormData","URLSearchParams","acc","_ref3","convertFormDataToSearchParams","convertSearchParamsToFormData","append","getLoaderMatchesUntilBoundary","boundaryId","boundaryMatches","values","nextUrl","navigationMatches","currentLoaderData","currentMatch","isNew","isMissingData","isNewLoader","currentRouteMatch","nextRouteMatch","shouldRevalidateLoader","currentParams","nextParams","defaultShouldRevalidate","isNewRouteInstance","fetcherMatches","fetcherMatch","currentPath","loaderMatch","routeChoice","loadLazyRouteModule","lazyRoute","routeToUpdate","routeUpdates","lazyRouteProperty","isPropertyStaticallyDefined","resultType","onReject","runHandler","handler","reject","abortPromise","race","context","requestContext","handlerError","catch","isResponse","headers","isStaticRequest","isSameBasename","isRouteRequest","response","contentType","statusCode","deferred","resolveData","isDeferredData","_result$init","_result$init2","Headers","processRouteLoaderData","foundError","loaderHeaders","newLoaderData","mergedLoaderData","reverse","find","_temp5","errorMessage","signals","isRevalidatingLoader","then","unwrap","unwrappedData","getAll","pathMatches"],"mappings":"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","file":"vendors~69b6d896-7849-4570-a210-2d9a518cd5fd--ishav~32999d39.js","sourcesContent":["export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","/**\n * React Router DOM v6.20.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */var React=require('__nr1-internal__').injectedPackages[\"react\"];var ReactDOM=require('__nr1-internal__').injectedPackages[\"react-dom\"];import{UNSAFE_mapRouteProperties,UNSAFE_DataRouterContext,UNSAFE_DataRouterStateContext,Router,UNSAFE_useRoutesImpl,UNSAFE_NavigationContext,useHref,useResolvedPath,useLocation,useNavigate,createPath,UNSAFE_useRouteId,UNSAFE_RouteContext,useMatches,useNavigation,useBlocker}from'react-router';export{AbortedDeferredError,Await,MemoryRouter,Navigate,NavigationType,Outlet,Route,Router,Routes,UNSAFE_DataRouterContext,UNSAFE_DataRouterStateContext,UNSAFE_LocationContext,UNSAFE_NavigationContext,UNSAFE_RouteContext,UNSAFE_useRouteId,createMemoryRouter,createPath,createRoutesFromChildren,createRoutesFromElements,defer,generatePath,isRouteErrorResponse,json,matchPath,matchRoutes,parsePath,redirect,redirectDocument,renderMatches,resolvePath,useActionData,useAsyncError,useAsyncValue,useBlocker,useHref,useInRouterContext,useLoaderData,useLocation,useMatch,useMatches,useNavigate,useNavigation,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRevalidator,useRouteError,useRouteLoaderData,useRoutes}from'react-router';import{stripBasename,UNSAFE_warning,createRouter,createBrowserHistory,createHashHistory,UNSAFE_ErrorResponseImpl,UNSAFE_invariant,joinPaths,IDLE_FETCHER,matchPath}from'@remix-run/router';function _extends(){_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}const defaultMethod=\"get\";const defaultEncType=\"application/x-www-form-urlencoded\";function isHtmlElement(object){return object!=null&&typeof object.tagName===\"string\";}function isButtonElement(object){return isHtmlElement(object)&&object.tagName.toLowerCase()===\"button\";}function isFormElement(object){return isHtmlElement(object)&&object.tagName.toLowerCase()===\"form\";}function isInputElement(object){return isHtmlElement(object)&&object.tagName.toLowerCase()===\"input\";}function isModifiedEvent(event){return!!(event.metaKey||event.altKey||event.ctrlKey||event.shiftKey);}function shouldProcessLinkClick(event,target){return event.button===0&&(// Ignore everything but left clicks\n!target||target===\"_self\")&&// Let browser handle \"target=_blank\" etc.\n!isModifiedEvent(event)// Ignore clicks with modifier keys\n;}/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */function createSearchParams(init){if(init===void 0){init=\"\";}return new URLSearchParams(typeof init===\"string\"||Array.isArray(init)||init instanceof URLSearchParams?init:Object.keys(init).reduce((memo,key)=>{let value=init[key];return memo.concat(Array.isArray(value)?value.map(v=>[key,v]):[[key,value]]);},[]));}function getSearchParamsForLocation(locationSearch,defaultSearchParams){let searchParams=createSearchParams(locationSearch);if(defaultSearchParams){// Use `defaultSearchParams.forEach(...)` here instead of iterating of\n// `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n// web extensions. Relevant Bugzilla tickets:\n// https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n// https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\ndefaultSearchParams.forEach((_,key)=>{if(!searchParams.has(key)){defaultSearchParams.getAll(key).forEach(value=>{searchParams.append(key,value);});}});}return searchParams;}// One-time check for submitter support\nlet _formDataSupportsSubmitter=null;function isFormDataSubmitterSupported(){if(_formDataSupportsSubmitter===null){try{new FormData(document.createElement(\"form\"),// @ts-expect-error if FormData supports the submitter parameter, this will throw\n0);_formDataSupportsSubmitter=false;}catch(e){_formDataSupportsSubmitter=true;}}return _formDataSupportsSubmitter;}const supportedFormEncTypes=new Set([\"application/x-www-form-urlencoded\",\"multipart/form-data\",\"text/plain\"]);function getFormEncType(encType){if(encType!=null&&!supportedFormEncTypes.has(encType)){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,\"\\\"\"+encType+\"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \"+(\"and will default to \\\"\"+defaultEncType+\"\\\"\")):void 0;return null;}return encType;}function getFormSubmissionInfo(target,basename){let method;let action;let encType;let formData;let body;if(isFormElement(target)){// When grabbing the action from the element, it will have had the basename\n// prefixed to ensure non-JS scenarios work, so strip it since we'll\n// re-prefix in the router\nlet attr=target.getAttribute(\"action\");action=attr?stripBasename(attr,basename):null;method=target.getAttribute(\"method\")||defaultMethod;encType=getFormEncType(target.getAttribute(\"enctype\"))||defaultEncType;formData=new FormData(target);}else if(isButtonElement(target)||isInputElement(target)&&(target.type===\"submit\"||target.type===\"image\")){let form=target.form;if(form==null){throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");}// <button>/<input type=\"submit\"> may override attributes of <form>\n// When grabbing the action from the element, it will have had the basename\n// prefixed to ensure non-JS scenarios work, so strip it since we'll\n// re-prefix in the router\nlet attr=target.getAttribute(\"formaction\")||form.getAttribute(\"action\");action=attr?stripBasename(attr,basename):null;method=target.getAttribute(\"formmethod\")||form.getAttribute(\"method\")||defaultMethod;encType=getFormEncType(target.getAttribute(\"formenctype\"))||getFormEncType(form.getAttribute(\"enctype\"))||defaultEncType;// Build a FormData object populated from a form and submitter\nformData=new FormData(form,target);// If this browser doesn't support the `FormData(el, submitter)` format,\n// then tack on the submitter value at the end.  This is a lightweight\n// solution that is not 100% spec compliant.  For complete support in older\n// browsers, consider using the `formdata-submitter-polyfill` package\nif(!isFormDataSubmitterSupported()){let{name,type,value}=target;if(type===\"image\"){let prefix=name?name+\".\":\"\";formData.append(prefix+\"x\",\"0\");formData.append(prefix+\"y\",\"0\");}else if(name){formData.append(name,value);}}}else if(isHtmlElement(target)){throw new Error(\"Cannot submit element that is not <form>, <button>, or \"+\"<input type=\\\"submit|image\\\">\");}else{method=defaultMethod;action=null;encType=defaultEncType;body=target;}// Send body for <Form encType=\"text/plain\" so we encode it into text\nif(formData&&encType===\"text/plain\"){body=formData;formData=undefined;}return{action,method:method.toLowerCase(),encType,formData,body};}const _excluded=[\"onClick\",\"relative\",\"reloadDocument\",\"replace\",\"state\",\"target\",\"to\",\"preventScrollReset\",\"unstable_viewTransition\"],_excluded2=[\"aria-current\",\"caseSensitive\",\"className\",\"end\",\"style\",\"to\",\"unstable_viewTransition\",\"children\"],_excluded3=[\"fetcherKey\",\"navigate\",\"reloadDocument\",\"replace\",\"state\",\"method\",\"action\",\"onSubmit\",\"relative\",\"preventScrollReset\",\"unstable_viewTransition\"];function createBrowserRouter(routes,opts){return createRouter({basename:opts==null?void 0:opts.basename,future:_extends({},opts==null?void 0:opts.future,{v7_prependBasename:true}),history:createBrowserHistory({window:opts==null?void 0:opts.window}),hydrationData:(opts==null?void 0:opts.hydrationData)||parseHydrationData(),routes,mapRouteProperties:UNSAFE_mapRouteProperties,window:opts==null?void 0:opts.window}).initialize();}function createHashRouter(routes,opts){return createRouter({basename:opts==null?void 0:opts.basename,future:_extends({},opts==null?void 0:opts.future,{v7_prependBasename:true}),history:createHashHistory({window:opts==null?void 0:opts.window}),hydrationData:(opts==null?void 0:opts.hydrationData)||parseHydrationData(),routes,mapRouteProperties:UNSAFE_mapRouteProperties,window:opts==null?void 0:opts.window}).initialize();}function parseHydrationData(){var _window;let state=(_window=window)==null?void 0:_window.__staticRouterHydrationData;if(state&&state.errors){state=_extends({},state,{errors:deserializeErrors(state.errors)});}return state;}function deserializeErrors(errors){if(!errors)return null;let entries=Object.entries(errors);let serialized={};for(let[key,val]of entries){// Hey you!  If you change this, please change the corresponding logic in\n// serializeErrors in react-router-dom/server.tsx :)\nif(val&&val.__type===\"RouteErrorResponse\"){serialized[key]=new UNSAFE_ErrorResponseImpl(val.status,val.statusText,val.data,val.internal===true);}else if(val&&val.__type===\"Error\"){// Attempt to reconstruct the right type of Error (i.e., ReferenceError)\nif(val.__subType){let ErrorConstructor=window[val.__subType];if(typeof ErrorConstructor===\"function\"){try{// @ts-expect-error\nlet error=new ErrorConstructor(val.message);// Wipe away the client-side stack trace.  Nothing to fill it in with\n// because we don't serialize SSR stack traces for security reasons\nerror.stack=\"\";serialized[key]=error;}catch(e){// no-op - fall through and create a normal Error\n}}}if(serialized[key]==null){let error=new Error(val.message);// Wipe away the client-side stack trace.  Nothing to fill it in with\n// because we don't serialize SSR stack traces for security reasons\nerror.stack=\"\";serialized[key]=error;}}else{serialized[key]=val;}}return serialized;}const ViewTransitionContext=/*#__PURE__*/React.createContext({isTransitioning:false});if(process.env.NODE_ENV!==\"production\"){ViewTransitionContext.displayName=\"ViewTransition\";}const FetchersContext=/*#__PURE__*/React.createContext(new Map());if(process.env.NODE_ENV!==\"production\"){FetchersContext.displayName=\"Fetchers\";}//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/const START_TRANSITION=\"startTransition\";const startTransitionImpl=React[START_TRANSITION];const FLUSH_SYNC=\"flushSync\";const flushSyncImpl=ReactDOM[FLUSH_SYNC];function startTransitionSafe(cb){if(startTransitionImpl){startTransitionImpl(cb);}else{cb();}}function flushSyncSafe(cb){if(flushSyncImpl){flushSyncImpl(cb);}else{cb();}}class Deferred{constructor(){this.status=\"pending\";this.promise=new Promise((resolve,reject)=>{this.resolve=value=>{if(this.status===\"pending\"){this.status=\"resolved\";resolve(value);}};this.reject=reason=>{if(this.status===\"pending\"){this.status=\"rejected\";reject(reason);}};});}}/**\n * Given a Remix Router instance, render the appropriate UI\n */function RouterProvider(_ref){let{fallbackElement,router,future}=_ref;let[state,setStateImpl]=React.useState(router.state);let[pendingState,setPendingState]=React.useState();let[vtContext,setVtContext]=React.useState({isTransitioning:false});let[renderDfd,setRenderDfd]=React.useState();let[transition,setTransition]=React.useState();let[interruption,setInterruption]=React.useState();let fetcherData=React.useRef(new Map());let{v7_startTransition}=future||{};let optInStartTransition=React.useCallback(cb=>{if(v7_startTransition){startTransitionSafe(cb);}else{cb();}},[v7_startTransition]);let setState=React.useCallback((newState,_ref2)=>{let{deletedFetchers,unstable_flushSync:flushSync,unstable_viewTransitionOpts:viewTransitionOpts}=_ref2;deletedFetchers.forEach(key=>fetcherData.current.delete(key));newState.fetchers.forEach((fetcher,key)=>{if(fetcher.data!==undefined){fetcherData.current.set(key,fetcher.data);}});let isViewTransitionUnavailable=router.window==null||typeof router.window.document.startViewTransition!==\"function\";// If this isn't a view transition or it's not available in this browser,\n// just update and be done with it\nif(!viewTransitionOpts||isViewTransitionUnavailable){if(flushSync){flushSyncSafe(()=>setStateImpl(newState));}else{optInStartTransition(()=>setStateImpl(newState));}return;}// flushSync + startViewTransition\nif(flushSync){// Flush through the context to mark DOM elements as transition=ing\nflushSyncSafe(()=>{// Cancel any pending transitions\nif(transition){renderDfd&&renderDfd.resolve();transition.skipTransition();}setVtContext({isTransitioning:true,flushSync:true,currentLocation:viewTransitionOpts.currentLocation,nextLocation:viewTransitionOpts.nextLocation});});// Update the DOM\nlet t=router.window.document.startViewTransition(()=>{flushSyncSafe(()=>setStateImpl(newState));});// Clean up after the animation completes\nt.finished.finally(()=>{flushSyncSafe(()=>{setRenderDfd(undefined);setTransition(undefined);setPendingState(undefined);setVtContext({isTransitioning:false});});});flushSyncSafe(()=>setTransition(t));return;}// startTransition + startViewTransition\nif(transition){// Interrupting an in-progress transition, cancel and let everything flush\n// out, and then kick off a new transition from the interruption state\nrenderDfd&&renderDfd.resolve();transition.skipTransition();setInterruption({state:newState,currentLocation:viewTransitionOpts.currentLocation,nextLocation:viewTransitionOpts.nextLocation});}else{// Completed navigation update with opted-in view transitions, let 'er rip\nsetPendingState(newState);setVtContext({isTransitioning:true,flushSync:false,currentLocation:viewTransitionOpts.currentLocation,nextLocation:viewTransitionOpts.nextLocation});}},[router.window,transition,renderDfd,fetcherData,optInStartTransition]);// Need to use a layout effect here so we are subscribed early enough to\n// pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\nReact.useLayoutEffect(()=>router.subscribe(setState),[router,setState]);// When we start a view transition, create a Deferred we can use for the\n// eventual \"completed\" render\nReact.useEffect(()=>{if(vtContext.isTransitioning&&!vtContext.flushSync){setRenderDfd(new Deferred());}},[vtContext]);// Once the deferred is created, kick off startViewTransition() to update the\n// DOM and then wait on the Deferred to resolve (indicating the DOM update has\n// happened)\nReact.useEffect(()=>{if(renderDfd&&pendingState&&router.window){let newState=pendingState;let renderPromise=renderDfd.promise;let transition=router.window.document.startViewTransition(async()=>{optInStartTransition(()=>setStateImpl(newState));await renderPromise;});transition.finished.finally(()=>{setRenderDfd(undefined);setTransition(undefined);setPendingState(undefined);setVtContext({isTransitioning:false});});setTransition(transition);}},[optInStartTransition,pendingState,renderDfd,router.window]);// When the new location finally renders and is committed to the DOM, this\n// effect will run to resolve the transition\nReact.useEffect(()=>{if(renderDfd&&pendingState&&state.location.key===pendingState.location.key){renderDfd.resolve();}},[renderDfd,transition,state.location,pendingState]);// If we get interrupted with a new navigation during a transition, we skip\n// the active transition, let it cleanup, then kick it off again here\nReact.useEffect(()=>{if(!vtContext.isTransitioning&&interruption){setPendingState(interruption.state);setVtContext({isTransitioning:true,flushSync:false,currentLocation:interruption.currentLocation,nextLocation:interruption.nextLocation});setInterruption(undefined);}},[vtContext.isTransitioning,interruption]);let navigator=React.useMemo(()=>{return{createHref:router.createHref,encodeLocation:router.encodeLocation,go:n=>router.navigate(n),push:(to,state,opts)=>router.navigate(to,{state,preventScrollReset:opts==null?void 0:opts.preventScrollReset}),replace:(to,state,opts)=>router.navigate(to,{replace:true,state,preventScrollReset:opts==null?void 0:opts.preventScrollReset})};},[router]);let basename=router.basename||\"/\";let dataRouterContext=React.useMemo(()=>({router,navigator,static:false,basename}),[router,navigator,basename]);// The fragment and {null} here are important!  We need them to keep React 18's\n// useId happy when we are server-rendering since we may have a <script> here\n// containing the hydrated server-side staticContext (from StaticRouterProvider).\n// useId relies on the component tree structure to generate deterministic id's\n// so we need to ensure it remains the same on the client even though\n// we don't need the <script> tag\nreturn/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider,{value:dataRouterContext},/*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider,{value:state},/*#__PURE__*/React.createElement(FetchersContext.Provider,{value:fetcherData.current},/*#__PURE__*/React.createElement(ViewTransitionContext.Provider,{value:vtContext},/*#__PURE__*/React.createElement(Router,{basename:basename,location:state.location,navigationType:state.historyAction,navigator:navigator},state.initialized?/*#__PURE__*/React.createElement(DataRoutes,{routes:router.routes,state:state}):fallbackElement))))),null);}function DataRoutes(_ref3){let{routes,state}=_ref3;return UNSAFE_useRoutesImpl(routes,undefined,state);}/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */function BrowserRouter(_ref4){let{basename,children,future,window}=_ref4;let historyRef=React.useRef();if(historyRef.current==null){historyRef.current=createBrowserHistory({window,v5Compat:true});}let history=historyRef.current;let[state,setStateImpl]=React.useState({action:history.action,location:history.location});let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{v7_startTransition&&startTransitionImpl?startTransitionImpl(()=>setStateImpl(newState)):setStateImpl(newState);},[setStateImpl,v7_startTransition]);React.useLayoutEffect(()=>history.listen(setState),[history,setState]);return/*#__PURE__*/React.createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */function HashRouter(_ref5){let{basename,children,future,window}=_ref5;let historyRef=React.useRef();if(historyRef.current==null){historyRef.current=createHashHistory({window,v5Compat:true});}let history=historyRef.current;let[state,setStateImpl]=React.useState({action:history.action,location:history.location});let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{v7_startTransition&&startTransitionImpl?startTransitionImpl(()=>setStateImpl(newState)):setStateImpl(newState);},[setStateImpl,v7_startTransition]);React.useLayoutEffect(()=>history.listen(setState),[history,setState]);return/*#__PURE__*/React.createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */function HistoryRouter(_ref6){let{basename,children,future,history}=_ref6;let[state,setStateImpl]=React.useState({action:history.action,location:history.location});let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{v7_startTransition&&startTransitionImpl?startTransitionImpl(()=>setStateImpl(newState)):setStateImpl(newState);},[setStateImpl,v7_startTransition]);React.useLayoutEffect(()=>history.listen(setState),[history,setState]);return/*#__PURE__*/React.createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}if(process.env.NODE_ENV!==\"production\"){HistoryRouter.displayName=\"unstable_HistoryRouter\";}const isBrowser=typeof window!==\"undefined\"&&typeof window.document!==\"undefined\"&&typeof window.document.createElement!==\"undefined\";const ABSOLUTE_URL_REGEX=/^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;/**\n * The public API for rendering a history-aware `<a>`.\n */const Link=/*#__PURE__*/React.forwardRef(function LinkWithRef(_ref7,ref){let{onClick,relative,reloadDocument,replace,state,target,to,preventScrollReset,unstable_viewTransition}=_ref7,rest=_objectWithoutPropertiesLoose(_ref7,_excluded);let{basename}=React.useContext(UNSAFE_NavigationContext);// Rendered into <a href> for absolute URLs\nlet absoluteHref;let isExternal=false;if(typeof to===\"string\"&&ABSOLUTE_URL_REGEX.test(to)){// Render the absolute href server- and client-side\nabsoluteHref=to;// Only check for external origins client-side\nif(isBrowser){try{let currentUrl=new URL(window.location.href);let targetUrl=to.startsWith(\"//\")?new URL(currentUrl.protocol+to):new URL(to);let path=stripBasename(targetUrl.pathname,basename);if(targetUrl.origin===currentUrl.origin&&path!=null){// Strip the protocol/origin/basename for same-origin absolute URLs\nto=path+targetUrl.search+targetUrl.hash;}else{isExternal=true;}}catch(e){// We can't do external URL detection without a valid URL\nprocess.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,\"<Link to=\\\"\"+to+\"\\\"> contains an invalid URL which will probably break \"+\"when clicked - please update to a valid URL path.\"):void 0;}}}// Rendered into <a href> for relative URLs\nlet href=useHref(to,{relative});let internalOnClick=useLinkClickHandler(to,{replace,state,target,preventScrollReset,relative,unstable_viewTransition});function handleClick(event){if(onClick)onClick(event);if(!event.defaultPrevented){internalOnClick(event);}}return/*#__PURE__*/ (// eslint-disable-next-line jsx-a11y/anchor-has-content\nReact.createElement(\"a\",_extends({},rest,{href:absoluteHref||href,onClick:isExternal||reloadDocument?onClick:handleClick,ref:ref,target:target})));});if(process.env.NODE_ENV!==\"production\"){Link.displayName=\"Link\";}/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */const NavLink=/*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref8,ref){let{\"aria-current\":ariaCurrentProp=\"page\",caseSensitive=false,className:classNameProp=\"\",end=false,style:styleProp,to,unstable_viewTransition,children}=_ref8,rest=_objectWithoutPropertiesLoose(_ref8,_excluded2);let path=useResolvedPath(to,{relative:rest.relative});let location=useLocation();let routerState=React.useContext(UNSAFE_DataRouterStateContext);let{navigator}=React.useContext(UNSAFE_NavigationContext);let isTransitioning=routerState!=null&&// Conditional usage is OK here because the usage of a data router is static\n// eslint-disable-next-line react-hooks/rules-of-hooks\nuseViewTransitionState(path)&&unstable_viewTransition===true;let toPathname=navigator.encodeLocation?navigator.encodeLocation(path).pathname:path.pathname;let locationPathname=location.pathname;let nextLocationPathname=routerState&&routerState.navigation&&routerState.navigation.location?routerState.navigation.location.pathname:null;if(!caseSensitive){locationPathname=locationPathname.toLowerCase();nextLocationPathname=nextLocationPathname?nextLocationPathname.toLowerCase():null;toPathname=toPathname.toLowerCase();}// If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n// we're looking for a slash _after_ what's in `to`.  For example:\n//\n// <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n// both want to look for a / at index 6 to match URL `/users/matt`\nconst endSlashPosition=toPathname!==\"/\"&&toPathname.endsWith(\"/\")?toPathname.length-1:toPathname.length;let isActive=locationPathname===toPathname||!end&&locationPathname.startsWith(toPathname)&&locationPathname.charAt(endSlashPosition)===\"/\";let isPending=nextLocationPathname!=null&&(nextLocationPathname===toPathname||!end&&nextLocationPathname.startsWith(toPathname)&&nextLocationPathname.charAt(toPathname.length)===\"/\");let renderProps={isActive,isPending,isTransitioning};let ariaCurrent=isActive?ariaCurrentProp:undefined;let className;if(typeof classNameProp===\"function\"){className=classNameProp(renderProps);}else{// If the className prop is not a function, we use a default `active`\n// class for <NavLink />s that are active. In v5 `active` was the default\n// value for `activeClassName`, but we are removing that API and can still\n// use the old default behavior for a cleaner upgrade path and keep the\n// simple styling rules working as they currently do.\nclassName=[classNameProp,isActive?\"active\":null,isPending?\"pending\":null,isTransitioning?\"transitioning\":null].filter(Boolean).join(\" \");}let style=typeof styleProp===\"function\"?styleProp(renderProps):styleProp;return/*#__PURE__*/React.createElement(Link,_extends({},rest,{\"aria-current\":ariaCurrent,className:className,ref:ref,style:style,to:to,unstable_viewTransition:unstable_viewTransition}),typeof children===\"function\"?children(renderProps):children);});if(process.env.NODE_ENV!==\"production\"){NavLink.displayName=\"NavLink\";}/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */const Form=/*#__PURE__*/React.forwardRef((_ref9,forwardedRef)=>{let{fetcherKey,navigate,reloadDocument,replace,state,method=defaultMethod,action,onSubmit,relative,preventScrollReset,unstable_viewTransition}=_ref9,props=_objectWithoutPropertiesLoose(_ref9,_excluded3);let submit=useSubmit();let formAction=useFormAction(action,{relative});let formMethod=method.toLowerCase()===\"get\"?\"get\":\"post\";let submitHandler=event=>{onSubmit&&onSubmit(event);if(event.defaultPrevented)return;event.preventDefault();let submitter=event.nativeEvent.submitter;let submitMethod=(submitter==null?void 0:submitter.getAttribute(\"formmethod\"))||method;submit(submitter||event.currentTarget,{fetcherKey,method:submitMethod,navigate,replace,state,relative,preventScrollReset,unstable_viewTransition});};return/*#__PURE__*/React.createElement(\"form\",_extends({ref:forwardedRef,method:formMethod,action:formAction,onSubmit:reloadDocument?onSubmit:submitHandler},props));});if(process.env.NODE_ENV!==\"production\"){Form.displayName=\"Form\";}/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */function ScrollRestoration(_ref10){let{getKey,storageKey}=_ref10;useScrollRestoration({getKey,storageKey});return null;}if(process.env.NODE_ENV!==\"production\"){ScrollRestoration.displayName=\"ScrollRestoration\";}//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;(function(DataRouterHook){DataRouterHook[\"UseScrollRestoration\"]=\"useScrollRestoration\";DataRouterHook[\"UseSubmit\"]=\"useSubmit\";DataRouterHook[\"UseSubmitFetcher\"]=\"useSubmitFetcher\";DataRouterHook[\"UseFetcher\"]=\"useFetcher\";DataRouterHook[\"useViewTransitionState\"]=\"useViewTransitionState\";})(DataRouterHook||(DataRouterHook={}));var DataRouterStateHook;(function(DataRouterStateHook){DataRouterStateHook[\"UseFetcher\"]=\"useFetcher\";DataRouterStateHook[\"UseFetchers\"]=\"useFetchers\";DataRouterStateHook[\"UseScrollRestoration\"]=\"useScrollRestoration\";})(DataRouterStateHook||(DataRouterStateHook={}));// Internal hooks\nfunction getDataRouterConsoleError(hookName){return hookName+\" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";}function useDataRouterContext(hookName){let ctx=React.useContext(UNSAFE_DataRouterContext);!ctx?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return ctx;}function useDataRouterState(hookName){let state=React.useContext(UNSAFE_DataRouterStateContext);!state?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return state;}// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */function useLinkClickHandler(to,_temp){let{target,replace:replaceProp,state,preventScrollReset,relative,unstable_viewTransition}=_temp===void 0?{}:_temp;let navigate=useNavigate();let location=useLocation();let path=useResolvedPath(to,{relative});return React.useCallback(event=>{if(shouldProcessLinkClick(event,target)){event.preventDefault();// If the URL hasn't changed, a regular <a> will do a replace instead of\n// a push, so do the same here unless the replace prop is explicitly set\nlet replace=replaceProp!==undefined?replaceProp:createPath(location)===createPath(path);navigate(to,{replace,state,preventScrollReset,relative,unstable_viewTransition});}},[location,navigate,path,replaceProp,state,target,to,preventScrollReset,relative,unstable_viewTransition]);}/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */function useSearchParams(defaultInit){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(typeof URLSearchParams!==\"undefined\",\"You cannot use the `useSearchParams` hook in a browser that does not \"+\"support the URLSearchParams API. If you need to support Internet \"+\"Explorer 11, we recommend you load a polyfill such as \"+\"https://github.com/ungap/url-search-params\\n\\n\"+\"If you're unsure how to load polyfills, we recommend you check out \"+\"https://polyfill.io/v3/ which provides some recommendations about how \"+\"to load polyfills only for users that need them, instead of for every \"+\"user.\"):void 0;let defaultSearchParamsRef=React.useRef(createSearchParams(defaultInit));let hasSetSearchParamsRef=React.useRef(false);let location=useLocation();let searchParams=React.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n// Once we call that we want those to take precedence, otherwise you can't\n// remove a param with setSearchParams({}) if it has an initial value\ngetSearchParamsForLocation(location.search,hasSetSearchParamsRef.current?null:defaultSearchParamsRef.current),[location.search]);let navigate=useNavigate();let setSearchParams=React.useCallback((nextInit,navigateOptions)=>{const newSearchParams=createSearchParams(typeof nextInit===\"function\"?nextInit(searchParams):nextInit);hasSetSearchParamsRef.current=true;navigate(\"?\"+newSearchParams,navigateOptions);},[navigate,searchParams]);return[searchParams,setSearchParams];}function validateClientSideSubmission(){if(typeof document===\"undefined\"){throw new Error(\"You are calling submit during the server render. \"+\"Try calling submit within a `useEffect` or callback instead.\");}}let fetcherId=0;let getUniqueFetcherId=()=>\"__\"+String(++fetcherId)+\"__\";/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */function useSubmit(){let{router}=useDataRouterContext(DataRouterHook.UseSubmit);let{basename}=React.useContext(UNSAFE_NavigationContext);let currentRouteId=UNSAFE_useRouteId();return React.useCallback(function(target,options){if(options===void 0){options={};}validateClientSideSubmission();let{action,method,encType,formData,body}=getFormSubmissionInfo(target,basename);if(options.navigate===false){let key=options.fetcherKey||getUniqueFetcherId();router.fetch(key,currentRouteId,options.action||action,{preventScrollReset:options.preventScrollReset,formData,body,formMethod:options.method||method,formEncType:options.encType||encType,unstable_flushSync:options.unstable_flushSync});}else{router.navigate(options.action||action,{preventScrollReset:options.preventScrollReset,formData,body,formMethod:options.method||method,formEncType:options.encType||encType,replace:options.replace,state:options.state,fromRouteId:currentRouteId,unstable_flushSync:options.unstable_flushSync,unstable_viewTransition:options.unstable_viewTransition});}},[router,basename,currentRouteId]);}// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action,_temp2){let{relative}=_temp2===void 0?{}:_temp2;let{basename}=React.useContext(UNSAFE_NavigationContext);let routeContext=React.useContext(UNSAFE_RouteContext);!routeContext?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"useFormAction must be used inside a RouteContext\"):UNSAFE_invariant(false):void 0;let[match]=routeContext.matches.slice(-1);// Shallow clone path so we can modify it below, otherwise we modify the\n// object referenced by useMemo inside useResolvedPath\nlet path=_extends({},useResolvedPath(action?action:\".\",{relative}));// Previously we set the default action to \".\". The problem with this is that\n// `useResolvedPath(\".\")` excludes search params of the resolved URL. This is\n// the intended behavior of when \".\" is specifically provided as\n// the form action, but inconsistent w/ browsers when the action is omitted.\n// https://github.com/remix-run/remix/issues/927\nlet location=useLocation();if(action==null){// Safe to write to this directly here since if action was undefined, we\n// would have called useResolvedPath(\".\") which will never include a search\npath.search=location.search;// When grabbing search params from the URL, remove any included ?index param\n// since it might not apply to our contextual route.  We add it back based\n// on match.route.index below\nlet params=new URLSearchParams(path.search);if(params.has(\"index\")&&params.get(\"index\")===\"\"){params.delete(\"index\");path.search=params.toString()?\"?\"+params.toString():\"\";}}if((!action||action===\".\")&&match.route.index){path.search=path.search?path.search.replace(/^\\?/,\"?index&\"):\"?index\";}// If we're operating within a basename, prepend it to the pathname prior\n// to creating the form action.  If this is a root navigation, then just use\n// the raw basename which allows the basename to have full control over the\n// presence of a trailing slash on root actions\nif(basename!==\"/\"){path.pathname=path.pathname===\"/\"?basename:joinPaths([basename,path.pathname]);}return createPath(path);}// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */function useFetcher(_temp3){var _route$matches;let{key}=_temp3===void 0?{}:_temp3;let{router}=useDataRouterContext(DataRouterHook.UseFetcher);let state=useDataRouterState(DataRouterStateHook.UseFetcher);let fetcherData=React.useContext(FetchersContext);let route=React.useContext(UNSAFE_RouteContext);let routeId=(_route$matches=route.matches[route.matches.length-1])==null?void 0:_route$matches.route.id;!fetcherData?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"useFetcher must be used inside a FetchersContext\"):UNSAFE_invariant(false):void 0;!route?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"useFetcher must be used inside a RouteContext\"):UNSAFE_invariant(false):void 0;!(routeId!=null)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"useFetcher can only be used on routes that contain a unique \\\"id\\\"\"):UNSAFE_invariant(false):void 0;// Fetcher key handling\nlet[fetcherKey,setFetcherKey]=React.useState(key||\"\");if(key&&key!==fetcherKey){setFetcherKey(key);}else if(!fetcherKey){setFetcherKey(getUniqueFetcherId());}// Registration/cleanup\nReact.useEffect(()=>{router.getFetcher(fetcherKey);return()=>{// Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n// will not delete immediately but instead queue up a delete after the\n// fetcher returns to an `idle` state\nrouter.deleteFetcher(fetcherKey);};},[router,fetcherKey]);// Fetcher additions\nlet load=React.useCallback((href,opts)=>{!routeId?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"No routeId available for fetcher.load()\"):UNSAFE_invariant(false):void 0;router.fetch(fetcherKey,routeId,href,opts);},[fetcherKey,routeId,router]);let submitImpl=useSubmit();let submit=React.useCallback((target,opts)=>{submitImpl(target,_extends({},opts,{navigate:false,fetcherKey}));},[fetcherKey,submitImpl]);let FetcherForm=React.useMemo(()=>{let FetcherForm=/*#__PURE__*/React.forwardRef((props,ref)=>{return/*#__PURE__*/React.createElement(Form,_extends({},props,{navigate:false,fetcherKey:fetcherKey,ref:ref}));});if(process.env.NODE_ENV!==\"production\"){FetcherForm.displayName=\"fetcher.Form\";}return FetcherForm;},[fetcherKey]);// Exposed FetcherWithComponents\nlet fetcher=state.fetchers.get(fetcherKey)||IDLE_FETCHER;let data=fetcherData.get(fetcherKey);let fetcherWithComponents=React.useMemo(()=>_extends({Form:FetcherForm,submit,load},fetcher,{data}),[FetcherForm,submit,load,fetcher,data]);return fetcherWithComponents;}/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */function useFetchers(){let state=useDataRouterState(DataRouterStateHook.UseFetchers);return Array.from(state.fetchers.entries()).map(_ref11=>{let[key,fetcher]=_ref11;return _extends({},fetcher,{key});});}const SCROLL_RESTORATION_STORAGE_KEY=\"react-router-scroll-positions\";let savedScrollPositions={};/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */function useScrollRestoration(_temp4){let{getKey,storageKey}=_temp4===void 0?{}:_temp4;let{router}=useDataRouterContext(DataRouterHook.UseScrollRestoration);let{restoreScrollPosition,preventScrollReset}=useDataRouterState(DataRouterStateHook.UseScrollRestoration);let{basename}=React.useContext(UNSAFE_NavigationContext);let location=useLocation();let matches=useMatches();let navigation=useNavigation();// Trigger manual scroll restoration while we're active\nReact.useEffect(()=>{window.history.scrollRestoration=\"manual\";return()=>{window.history.scrollRestoration=\"auto\";};},[]);// Save positions on pagehide\nusePageHide(React.useCallback(()=>{if(navigation.state===\"idle\"){let key=(getKey?getKey(location,matches):null)||location.key;savedScrollPositions[key]=window.scrollY;}try{sessionStorage.setItem(storageKey||SCROLL_RESTORATION_STORAGE_KEY,JSON.stringify(savedScrollPositions));}catch(error){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,\"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\"+error+\").\"):void 0;}window.history.scrollRestoration=\"auto\";},[storageKey,getKey,navigation.state,location,matches]));// Read in any saved scroll locations\nif(typeof document!==\"undefined\"){// eslint-disable-next-line react-hooks/rules-of-hooks\nReact.useLayoutEffect(()=>{try{let sessionPositions=sessionStorage.getItem(storageKey||SCROLL_RESTORATION_STORAGE_KEY);if(sessionPositions){savedScrollPositions=JSON.parse(sessionPositions);}}catch(e){// no-op, use default empty object\n}},[storageKey]);// Enable scroll restoration in the router\n// eslint-disable-next-line react-hooks/rules-of-hooks\nReact.useLayoutEffect(()=>{let getKeyWithoutBasename=getKey&&basename!==\"/\"?(location,matches)=>getKey(// Strip the basename to match useLocation()\n_extends({},location,{pathname:stripBasename(location.pathname,basename)||location.pathname}),matches):getKey;let disableScrollRestoration=router==null?void 0:router.enableScrollRestoration(savedScrollPositions,()=>window.scrollY,getKeyWithoutBasename);return()=>disableScrollRestoration&&disableScrollRestoration();},[router,basename,getKey]);// Restore scrolling when state.restoreScrollPosition changes\n// eslint-disable-next-line react-hooks/rules-of-hooks\nReact.useLayoutEffect(()=>{// Explicit false means don't do anything (used for submissions)\nif(restoreScrollPosition===false){return;}// been here before, scroll to it\nif(typeof restoreScrollPosition===\"number\"){window.scrollTo(0,restoreScrollPosition);return;}// try to scroll to the hash\nif(location.hash){let el=document.getElementById(decodeURIComponent(location.hash.slice(1)));if(el){el.scrollIntoView();return;}}// Don't reset if this navigation opted out\nif(preventScrollReset===true){return;}// otherwise go to the top on new locations\nwindow.scrollTo(0,0);},[location,restoreScrollPosition,preventScrollReset]);}}/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */function useBeforeUnload(callback,options){let{capture}=options||{};React.useEffect(()=>{let opts=capture!=null?{capture}:undefined;window.addEventListener(\"beforeunload\",callback,opts);return()=>{window.removeEventListener(\"beforeunload\",callback,opts);};},[callback,capture]);}/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */function usePageHide(callback,options){let{capture}=options||{};React.useEffect(()=>{let opts=capture!=null?{capture}:undefined;window.addEventListener(\"pagehide\",callback,opts);return()=>{window.removeEventListener(\"pagehide\",callback,opts);};},[callback,capture]);}/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */function usePrompt(_ref12){let{when,message}=_ref12;let blocker=useBlocker(when);React.useEffect(()=>{if(blocker.state===\"blocked\"){let proceed=window.confirm(message);if(proceed){// This timeout is needed to avoid a weird \"race\" on POP navigations\n// between the `window.history` revert navigation and the result of\n// `window.confirm`\nsetTimeout(blocker.proceed,0);}else{blocker.reset();}}},[blocker,message]);React.useEffect(()=>{if(blocker.state===\"blocked\"&&!when){blocker.reset();}},[blocker,when]);}/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */function useViewTransitionState(to,opts){if(opts===void 0){opts={};}let vtContext=React.useContext(ViewTransitionContext);!(vtContext!=null)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \"+\"Did you accidentally import `RouterProvider` from `react-router`?\"):UNSAFE_invariant(false):void 0;let{basename}=useDataRouterContext(DataRouterHook.useViewTransitionState);let path=useResolvedPath(to,{relative:opts.relative});if(!vtContext.isTransitioning){return false;}let currentPath=stripBasename(vtContext.currentLocation.pathname,basename)||vtContext.currentLocation.pathname;let nextPath=stripBasename(vtContext.nextLocation.pathname,basename)||vtContext.nextLocation.pathname;// Transition is active if we're going to or coming from the indicated\n// destination.  This ensures that other PUSH navigations that reverse\n// an indicated transition apply.  I.e., on the list view you have:\n//\n//   <NavLink to=\"/details/1\" unstable_viewTransition>\n//\n// If you click the breadcrumb back to the list view:\n//\n//   <NavLink to=\"/list\" unstable_viewTransition>\n//\n// We should apply the transition because it's indicated as active going\n// from /list -> /details/1 and therefore should be active on the reverse\n// (even though this isn't strictly a POP reverse)\nreturn matchPath(path.pathname,nextPath)!=null||matchPath(path.pathname,currentPath)!=null;}//#endregion\nexport{BrowserRouter,Form,HashRouter,Link,NavLink,RouterProvider,ScrollRestoration,FetchersContext as UNSAFE_FetchersContext,ViewTransitionContext as UNSAFE_ViewTransitionContext,useScrollRestoration as UNSAFE_useScrollRestoration,createBrowserRouter,createHashRouter,createSearchParams,HistoryRouter as unstable_HistoryRouter,usePrompt as unstable_usePrompt,useViewTransitionState as unstable_useViewTransitionState,useBeforeUnload,useFetcher,useFetchers,useFormAction,useLinkClickHandler,useSearchParams,useSubmit};","/**\n * React Router v6.20.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */var React=require('__nr1-internal__').injectedPackages[\"react\"];import{UNSAFE_invariant,joinPaths,matchPath,UNSAFE_getPathContributingMatches,UNSAFE_warning,resolveTo,parsePath,matchRoutes,Action,UNSAFE_convertRouteMatchToUiMatch,stripBasename,IDLE_BLOCKER,isRouteErrorResponse,createMemoryHistory,AbortedDeferredError,createRouter}from'@remix-run/router';export{AbortedDeferredError,Action as NavigationType,createPath,defer,generatePath,isRouteErrorResponse,json,matchPath,matchRoutes,parsePath,redirect,redirectDocument,resolvePath}from'@remix-run/router';function _extends(){_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){DataRouterContext.displayName=\"DataRouter\";}const DataRouterStateContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){DataRouterStateContext.displayName=\"DataRouterState\";}const AwaitContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){AwaitContext.displayName=\"Await\";}/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */const NavigationContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){NavigationContext.displayName=\"Navigation\";}const LocationContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){LocationContext.displayName=\"Location\";}const RouteContext=/*#__PURE__*/React.createContext({outlet:null,matches:[],isDataRoute:false});if(process.env.NODE_ENV!==\"production\"){RouteContext.displayName=\"Route\";}const RouteErrorContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){RouteErrorContext.displayName=\"RouteError\";}/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */function useHref(to,_temp){let{relative}=_temp===void 0?{}:_temp;!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useHref() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;let{basename,navigator}=React.useContext(NavigationContext);let{hash,pathname,search}=useResolvedPath(to,{relative});let joinedPathname=pathname;// If we're operating within a basename, prepend it to the pathname prior\n// to creating the href.  If this is a root navigation, then just use the raw\n// basename which allows the basename to have full control over the presence\n// of a trailing slash on root links\nif(basename!==\"/\"){joinedPathname=pathname===\"/\"?basename:joinPaths([basename,pathname]);}return navigator.createHref({pathname:joinedPathname,search,hash});}/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */function useInRouterContext(){return React.useContext(LocationContext)!=null;}/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */function useLocation(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useLocation() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;return React.useContext(LocationContext).location;}/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */function useNavigationType(){return React.useContext(LocationContext).navigationType;}/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */function useMatch(pattern){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useMatch() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;let{pathname}=useLocation();return React.useMemo(()=>matchPath(pattern,pathname),[pathname,pattern]);}/**\n * The interface for the navigate() function returned from useNavigate().\n */const navigateEffectWarning=\"You should call navigate() in a React.useEffect(), not when \"+\"your component is first rendered.\";// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb){let isStatic=React.useContext(NavigationContext).static;if(!isStatic){// We should be able to get rid of this once react 18.3 is released\n// See: https://github.com/facebook/react/pull/26395\n// eslint-disable-next-line react-hooks/rules-of-hooks\nReact.useLayoutEffect(cb);}}/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */function useNavigate(){let{isDataRoute}=React.useContext(RouteContext);// Conditional usage is OK here because the usage of a data router is static\n// eslint-disable-next-line react-hooks/rules-of-hooks\nreturn isDataRoute?useNavigateStable():useNavigateUnstable();}function useNavigateUnstable(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useNavigate() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;let dataRouterContext=React.useContext(DataRouterContext);let{basename,navigator}=React.useContext(NavigationContext);let{matches}=React.useContext(RouteContext);let{pathname:locationPathname}=useLocation();let routePathnamesJson=JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match=>match.pathnameBase));let activeRef=React.useRef(false);useIsomorphicLayoutEffect(()=>{activeRef.current=true;});let navigate=React.useCallback(function(to,options){if(options===void 0){options={};}process.env.NODE_ENV!==\"production\"?UNSAFE_warning(activeRef.current,navigateEffectWarning):void 0;// Short circuit here since if this happens on first render the navigate\n// is useless because we haven't wired up our history listener yet\nif(!activeRef.current)return;if(typeof to===\"number\"){navigator.go(to);return;}let path=resolveTo(to,JSON.parse(routePathnamesJson),locationPathname,options.relative===\"path\");// If we're operating within a basename, prepend it to the pathname prior\n// to handing off to history (but only if we're not in a data router,\n// otherwise it'll prepend the basename inside of the router).\n// If this is a root navigation, then we navigate to the raw basename\n// which allows the basename to have full control over the presence of a\n// trailing slash on root links\nif(dataRouterContext==null&&basename!==\"/\"){path.pathname=path.pathname===\"/\"?basename:joinPaths([basename,path.pathname]);}(!!options.replace?navigator.replace:navigator.push)(path,options.state,options);},[basename,navigator,routePathnamesJson,locationPathname,dataRouterContext]);return navigate;}const OutletContext=/*#__PURE__*/React.createContext(null);/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */function useOutletContext(){return React.useContext(OutletContext);}/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */function useOutlet(context){let outlet=React.useContext(RouteContext).outlet;if(outlet){return/*#__PURE__*/React.createElement(OutletContext.Provider,{value:context},outlet);}return outlet;}/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */function useParams(){let{matches}=React.useContext(RouteContext);let routeMatch=matches[matches.length-1];return routeMatch?routeMatch.params:{};}/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */function useResolvedPath(to,_temp2){let{relative}=_temp2===void 0?{}:_temp2;let{matches}=React.useContext(RouteContext);let{pathname:locationPathname}=useLocation();let routePathnamesJson=JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match=>match.pathnameBase));return React.useMemo(()=>resolveTo(to,JSON.parse(routePathnamesJson),locationPathname,relative===\"path\"),[to,routePathnamesJson,locationPathname,relative]);}/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */function useRoutes(routes,locationArg){return useRoutesImpl(routes,locationArg);}// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes,locationArg,dataRouterState){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useRoutes() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;let{navigator}=React.useContext(NavigationContext);let{matches:parentMatches}=React.useContext(RouteContext);let routeMatch=parentMatches[parentMatches.length-1];let parentParams=routeMatch?routeMatch.params:{};let parentPathname=routeMatch?routeMatch.pathname:\"/\";let parentPathnameBase=routeMatch?routeMatch.pathnameBase:\"/\";let parentRoute=routeMatch&&routeMatch.route;if(process.env.NODE_ENV!==\"production\"){// You won't get a warning about 2 different <Routes> under a <Route>\n// without a trailing *, but this is a best-effort warning anyway since we\n// cannot even give the warning unless they land at the parent route.\n//\n// Example:\n//\n// <Routes>\n//   {/* This route path MUST end with /* because otherwise\n//       it will never match /blog/post/123 */}\n//   <Route path=\"blog\" element={<Blog />} />\n//   <Route path=\"blog/feed\" element={<BlogFeed />} />\n// </Routes>\n//\n// function Blog() {\n//   return (\n//     <Routes>\n//       <Route path=\"post/:id\" element={<Post />} />\n//     </Routes>\n//   );\n// }\nlet parentPath=parentRoute&&parentRoute.path||\"\";warningOnce(parentPathname,!parentRoute||parentPath.endsWith(\"*\"),\"You rendered descendant <Routes> (or called `useRoutes()`) at \"+(\"\\\"\"+parentPathname+\"\\\" (under <Route path=\\\"\"+parentPath+\"\\\">) but the \")+\"parent route path has no trailing \\\"*\\\". This means if you navigate \"+\"deeper, the parent won't match anymore and therefore the child \"+\"routes will never render.\\n\\n\"+(\"Please change the parent <Route path=\\\"\"+parentPath+\"\\\"> to <Route \")+(\"path=\\\"\"+(parentPath===\"/\"?\"*\":parentPath+\"/*\")+\"\\\">.\"));}let locationFromContext=useLocation();let location;if(locationArg){var _parsedLocationArg$pa;let parsedLocationArg=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;!(parentPathnameBase===\"/\"||((_parsedLocationArg$pa=parsedLocationArg.pathname)==null?void 0:_parsedLocationArg$pa.startsWith(parentPathnameBase)))?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \"+\"the location pathname must begin with the portion of the URL pathname that was \"+(\"matched by all parent routes. The current pathname base is \\\"\"+parentPathnameBase+\"\\\" \")+(\"but pathname \\\"\"+parsedLocationArg.pathname+\"\\\" was given in the `location` prop.\")):UNSAFE_invariant(false):void 0;location=parsedLocationArg;}else{location=locationFromContext;}let pathname=location.pathname||\"/\";let remainingPathname=parentPathnameBase===\"/\"?pathname:pathname.slice(parentPathnameBase.length)||\"/\";let matches=matchRoutes(routes,{pathname:remainingPathname});if(process.env.NODE_ENV!==\"production\"){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(parentRoute||matches!=null,\"No routes matched location \\\"\"+location.pathname+location.search+location.hash+\"\\\" \"):void 0;process.env.NODE_ENV!==\"production\"?UNSAFE_warning(matches==null||matches[matches.length-1].route.element!==undefined||matches[matches.length-1].route.Component!==undefined,\"Matched leaf route at location \\\"\"+location.pathname+location.search+location.hash+\"\\\" \"+\"does not have an element or Component. This means it will render an <Outlet /> with a \"+\"null value by default resulting in an \\\"empty\\\" page.\"):void 0;}let renderedMatches=_renderMatches(matches&&matches.map(match=>Object.assign({},match,{params:Object.assign({},parentParams,match.params),pathname:joinPaths([parentPathnameBase,// Re-encode pathnames that were decoded inside matchRoutes\nnavigator.encodeLocation?navigator.encodeLocation(match.pathname).pathname:match.pathname]),pathnameBase:match.pathnameBase===\"/\"?parentPathnameBase:joinPaths([parentPathnameBase,// Re-encode pathnames that were decoded inside matchRoutes\nnavigator.encodeLocation?navigator.encodeLocation(match.pathnameBase).pathname:match.pathnameBase])})),parentMatches,dataRouterState);// When a user passes in a `locationArg`, the associated routes need to\n// be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n// to use the scoped location instead of the global location.\nif(locationArg&&renderedMatches){return/*#__PURE__*/React.createElement(LocationContext.Provider,{value:{location:_extends({pathname:\"/\",search:\"\",hash:\"\",state:null,key:\"default\"},location),navigationType:Action.Pop}},renderedMatches);}return renderedMatches;}function DefaultErrorComponent(){let error=useRouteError();let message=isRouteErrorResponse(error)?error.status+\" \"+error.statusText:error instanceof Error?error.message:JSON.stringify(error);let stack=error instanceof Error?error.stack:null;let lightgrey=\"rgba(200,200,200, 0.5)\";let preStyles={padding:\"0.5rem\",backgroundColor:lightgrey};let codeStyles={padding:\"2px 4px\",backgroundColor:lightgrey};let devInfo=null;if(process.env.NODE_ENV!==\"production\"){console.error(\"Error handled by React Router default ErrorBoundary:\",error);devInfo=/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(\"p\",null,\"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"),/*#__PURE__*/React.createElement(\"p\",null,\"You can provide a way better UX than this when your app throws errors by providing your own \",/*#__PURE__*/React.createElement(\"code\",{style:codeStyles},\"ErrorBoundary\"),\" or\",\" \",/*#__PURE__*/React.createElement(\"code\",{style:codeStyles},\"errorElement\"),\" prop on your route.\"));}return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(\"h2\",null,\"Unexpected Application Error!\"),/*#__PURE__*/React.createElement(\"h3\",{style:{fontStyle:\"italic\"}},message),stack?/*#__PURE__*/React.createElement(\"pre\",{style:preStyles},stack):null,devInfo);}const defaultErrorElement=/*#__PURE__*/React.createElement(DefaultErrorComponent,null);class RenderErrorBoundary extends React.Component{constructor(props){super(props);this.state={location:props.location,revalidation:props.revalidation,error:props.error};}static getDerivedStateFromError(error){return{error:error};}static getDerivedStateFromProps(props,state){// When we get into an error state, the user will likely click \"back\" to the\n// previous page that didn't have an error. Because this wraps the entire\n// application, that will have no effect--the error page continues to display.\n// This gives us a mechanism to recover from the error when the location changes.\n//\n// Whether we're in an error state or not, we update the location in state\n// so that when we are in an error state, it gets reset when a new location\n// comes in and the user recovers from the error.\nif(state.location!==props.location||state.revalidation!==\"idle\"&&props.revalidation===\"idle\"){return{error:props.error,location:props.location,revalidation:props.revalidation};}// If we're not changing locations, preserve the location but still surface\n// any new errors that may come through. We retain the existing error, we do\n// this because the error provided from the app state may be cleared without\n// the location changing.\nreturn{error:props.error||state.error,location:state.location,revalidation:props.revalidation||state.revalidation};}componentDidCatch(error,errorInfo){console.error(\"React Router caught the following error during render\",error,errorInfo);}render(){return this.state.error?/*#__PURE__*/React.createElement(RouteContext.Provider,{value:this.props.routeContext},/*#__PURE__*/React.createElement(RouteErrorContext.Provider,{value:this.state.error,children:this.props.component})):this.props.children;}}function RenderedRoute(_ref){let{routeContext,match,children}=_ref;let dataRouterContext=React.useContext(DataRouterContext);// Track how deep we got in our render pass to emulate SSR componentDidCatch\n// in a DataStaticRouter\nif(dataRouterContext&&dataRouterContext.static&&dataRouterContext.staticContext&&(match.route.errorElement||match.route.ErrorBoundary)){dataRouterContext.staticContext._deepestRenderedBoundaryId=match.route.id;}return/*#__PURE__*/React.createElement(RouteContext.Provider,{value:routeContext},children);}function _renderMatches(matches,parentMatches,dataRouterState){var _dataRouterState2;if(parentMatches===void 0){parentMatches=[];}if(dataRouterState===void 0){dataRouterState=null;}if(matches==null){var _dataRouterState;if((_dataRouterState=dataRouterState)!=null&&_dataRouterState.errors){// Don't bail if we have data router errors so we can render them in the\n// boundary.  Use the pre-matched (or shimmed) matches\nmatches=dataRouterState.matches;}else{return null;}}let renderedMatches=matches;// If we have data errors, trim matches to the highest error boundary\nlet errors=(_dataRouterState2=dataRouterState)==null?void 0:_dataRouterState2.errors;if(errors!=null){let errorIndex=renderedMatches.findIndex(m=>m.route.id&&(errors==null?void 0:errors[m.route.id]));!(errorIndex>=0)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"Could not find a matching route for errors on route IDs: \"+Object.keys(errors).join(\",\")):UNSAFE_invariant(false):void 0;renderedMatches=renderedMatches.slice(0,Math.min(renderedMatches.length,errorIndex+1));}return renderedMatches.reduceRight((outlet,match,index)=>{let error=match.route.id?errors==null?void 0:errors[match.route.id]:null;// Only data routers handle errors\nlet errorElement=null;if(dataRouterState){errorElement=match.route.errorElement||defaultErrorElement;}let matches=parentMatches.concat(renderedMatches.slice(0,index+1));let getChildren=()=>{let children;if(error){children=errorElement;}else if(match.route.Component){// Note: This is a de-optimized path since React won't re-use the\n// ReactElement since it's identity changes with each new\n// React.createElement call.  We keep this so folks can use\n// `<Route Component={...}>` in `<Routes>` but generally `Component`\n// usage is only advised in `RouterProvider` when we can convert it to\n// `element` ahead of time.\nchildren=/*#__PURE__*/React.createElement(match.route.Component,null);}else if(match.route.element){children=match.route.element;}else{children=outlet;}return/*#__PURE__*/React.createElement(RenderedRoute,{match:match,routeContext:{outlet,matches,isDataRoute:dataRouterState!=null},children:children});};// Only wrap in an error boundary within data router usages when we have an\n// ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n// an ancestor ErrorBoundary/errorElement\nreturn dataRouterState&&(match.route.ErrorBoundary||match.route.errorElement||index===0)?/*#__PURE__*/React.createElement(RenderErrorBoundary,{location:dataRouterState.location,revalidation:dataRouterState.revalidation,component:errorElement,error:error,children:getChildren(),routeContext:{outlet:null,matches,isDataRoute:true}}):getChildren();},null);}var DataRouterHook=/*#__PURE__*/function(DataRouterHook){DataRouterHook[\"UseBlocker\"]=\"useBlocker\";DataRouterHook[\"UseRevalidator\"]=\"useRevalidator\";DataRouterHook[\"UseNavigateStable\"]=\"useNavigate\";return DataRouterHook;}(DataRouterHook||{});var DataRouterStateHook=/*#__PURE__*/function(DataRouterStateHook){DataRouterStateHook[\"UseBlocker\"]=\"useBlocker\";DataRouterStateHook[\"UseLoaderData\"]=\"useLoaderData\";DataRouterStateHook[\"UseActionData\"]=\"useActionData\";DataRouterStateHook[\"UseRouteError\"]=\"useRouteError\";DataRouterStateHook[\"UseNavigation\"]=\"useNavigation\";DataRouterStateHook[\"UseRouteLoaderData\"]=\"useRouteLoaderData\";DataRouterStateHook[\"UseMatches\"]=\"useMatches\";DataRouterStateHook[\"UseRevalidator\"]=\"useRevalidator\";DataRouterStateHook[\"UseNavigateStable\"]=\"useNavigate\";DataRouterStateHook[\"UseRouteId\"]=\"useRouteId\";return DataRouterStateHook;}(DataRouterStateHook||{});function getDataRouterConsoleError(hookName){return hookName+\" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";}function useDataRouterContext(hookName){let ctx=React.useContext(DataRouterContext);!ctx?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return ctx;}function useDataRouterState(hookName){let state=React.useContext(DataRouterStateContext);!state?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return state;}function useRouteContext(hookName){let route=React.useContext(RouteContext);!route?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return route;}// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName){let route=useRouteContext(hookName);let thisRoute=route.matches[route.matches.length-1];!thisRoute.route.id?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,hookName+\" can only be used on routes that contain a unique \\\"id\\\"\"):UNSAFE_invariant(false):void 0;return thisRoute.route.id;}/**\n * Returns the ID for the nearest contextual route\n */function useRouteId(){return useCurrentRouteId(DataRouterStateHook.UseRouteId);}/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */function useNavigation(){let state=useDataRouterState(DataRouterStateHook.UseNavigation);return state.navigation;}/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */function useRevalidator(){let dataRouterContext=useDataRouterContext(DataRouterHook.UseRevalidator);let state=useDataRouterState(DataRouterStateHook.UseRevalidator);return React.useMemo(()=>({revalidate:dataRouterContext.router.revalidate,state:state.revalidation}),[dataRouterContext.router.revalidate,state.revalidation]);}/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */function useMatches(){let{matches,loaderData}=useDataRouterState(DataRouterStateHook.UseMatches);return React.useMemo(()=>matches.map(m=>UNSAFE_convertRouteMatchToUiMatch(m,loaderData)),[matches,loaderData]);}/**\n * Returns the loader data for the nearest ancestor Route loader\n */function useLoaderData(){let state=useDataRouterState(DataRouterStateHook.UseLoaderData);let routeId=useCurrentRouteId(DataRouterStateHook.UseLoaderData);if(state.errors&&state.errors[routeId]!=null){console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \"+routeId+\")\");return undefined;}return state.loaderData[routeId];}/**\n * Returns the loaderData for the given routeId\n */function useRouteLoaderData(routeId){let state=useDataRouterState(DataRouterStateHook.UseRouteLoaderData);return state.loaderData[routeId];}/**\n * Returns the action data for the nearest ancestor Route action\n */function useActionData(){let state=useDataRouterState(DataRouterStateHook.UseActionData);let routeId=useCurrentRouteId(DataRouterStateHook.UseLoaderData);return state.actionData?state.actionData[routeId]:undefined;}/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */function useRouteError(){var _state$errors;let error=React.useContext(RouteErrorContext);let state=useDataRouterState(DataRouterStateHook.UseRouteError);let routeId=useCurrentRouteId(DataRouterStateHook.UseRouteError);// If this was a render error, we put it in a RouteError context inside\n// of RenderErrorBoundary\nif(error){return error;}// Otherwise look for errors from our data router state\nreturn(_state$errors=state.errors)==null?void 0:_state$errors[routeId];}/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */function useAsyncValue(){let value=React.useContext(AwaitContext);return value==null?void 0:value._data;}/**\n * Returns the error from the nearest ancestor `<Await />` value\n */function useAsyncError(){let value=React.useContext(AwaitContext);return value==null?void 0:value._error;}let blockerId=0;/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */function useBlocker(shouldBlock){let{router,basename}=useDataRouterContext(DataRouterHook.UseBlocker);let state=useDataRouterState(DataRouterStateHook.UseBlocker);let[blockerKey,setBlockerKey]=React.useState(\"\");let blockerFunction=React.useCallback(arg=>{if(typeof shouldBlock!==\"function\"){return!!shouldBlock;}if(basename===\"/\"){return shouldBlock(arg);}// If they provided us a function and we've got an active basename, strip\n// it from the locations we expose to the user to match the behavior of\n// useLocation\nlet{currentLocation,nextLocation,historyAction}=arg;return shouldBlock({currentLocation:_extends({},currentLocation,{pathname:stripBasename(currentLocation.pathname,basename)||currentLocation.pathname}),nextLocation:_extends({},nextLocation,{pathname:stripBasename(nextLocation.pathname,basename)||nextLocation.pathname}),historyAction});},[basename,shouldBlock]);// This effect is in charge of blocker key assignment and deletion (which is\n// tightly coupled to the key)\nReact.useEffect(()=>{let key=String(++blockerId);setBlockerKey(key);return()=>router.deleteBlocker(key);},[router]);// This effect handles assigning the blockerFunction.  This is to handle\n// unstable blocker function identities, and happens only after the prior\n// effect so we don't get an orphaned blockerFunction in the router with a\n// key of \"\".  Until then we just have the IDLE_BLOCKER.\nReact.useEffect(()=>{if(blockerKey!==\"\"){router.getBlocker(blockerKey,blockerFunction);}},[router,blockerKey,blockerFunction]);// Prefer the blocker from `state` not `router.state` since DataRouterContext\n// is memoized so this ensures we update on blocker state updates\nreturn blockerKey&&state.blockers.has(blockerKey)?state.blockers.get(blockerKey):IDLE_BLOCKER;}/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */function useNavigateStable(){let{router}=useDataRouterContext(DataRouterHook.UseNavigateStable);let id=useCurrentRouteId(DataRouterStateHook.UseNavigateStable);let activeRef=React.useRef(false);useIsomorphicLayoutEffect(()=>{activeRef.current=true;});let navigate=React.useCallback(function(to,options){if(options===void 0){options={};}process.env.NODE_ENV!==\"production\"?UNSAFE_warning(activeRef.current,navigateEffectWarning):void 0;// Short circuit here since if this happens on first render the navigate\n// is useless because we haven't wired up our router subscriber yet\nif(!activeRef.current)return;if(typeof to===\"number\"){router.navigate(to);}else{router.navigate(to,_extends({fromRouteId:id},options));}},[router,id]);return navigate;}const alreadyWarned={};function warningOnce(key,cond,message){if(!cond&&!alreadyWarned[key]){alreadyWarned[key]=true;process.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,message):void 0;}}/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/const START_TRANSITION=\"startTransition\";const startTransitionImpl=React[START_TRANSITION];/**\n * Given a Remix Router instance, render the appropriate UI\n */function RouterProvider(_ref){let{fallbackElement,router,future}=_ref;let[state,setStateImpl]=React.useState(router.state);let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{if(v7_startTransition&&startTransitionImpl){startTransitionImpl(()=>setStateImpl(newState));}else{setStateImpl(newState);}},[setStateImpl,v7_startTransition]);// Need to use a layout effect here so we are subscribed early enough to\n// pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\nReact.useLayoutEffect(()=>router.subscribe(setState),[router,setState]);let navigator=React.useMemo(()=>{return{createHref:router.createHref,encodeLocation:router.encodeLocation,go:n=>router.navigate(n),push:(to,state,opts)=>router.navigate(to,{state,preventScrollReset:opts==null?void 0:opts.preventScrollReset}),replace:(to,state,opts)=>router.navigate(to,{replace:true,state,preventScrollReset:opts==null?void 0:opts.preventScrollReset})};},[router]);let basename=router.basename||\"/\";let dataRouterContext=React.useMemo(()=>({router,navigator,static:false,basename}),[router,navigator,basename]);// The fragment and {null} here are important!  We need them to keep React 18's\n// useId happy when we are server-rendering since we may have a <script> here\n// containing the hydrated server-side staticContext (from StaticRouterProvider).\n// useId relies on the component tree structure to generate deterministic id's\n// so we need to ensure it remains the same on the client even though\n// we don't need the <script> tag\nreturn/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(DataRouterContext.Provider,{value:dataRouterContext},/*#__PURE__*/React.createElement(DataRouterStateContext.Provider,{value:state},/*#__PURE__*/React.createElement(Router,{basename:basename,location:state.location,navigationType:state.historyAction,navigator:navigator},state.initialized?/*#__PURE__*/React.createElement(DataRoutes,{routes:router.routes,state:state}):fallbackElement))),null);}function DataRoutes(_ref2){let{routes,state}=_ref2;return useRoutesImpl(routes,undefined,state);}/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */function MemoryRouter(_ref3){let{basename,children,initialEntries,initialIndex,future}=_ref3;let historyRef=React.useRef();if(historyRef.current==null){historyRef.current=createMemoryHistory({initialEntries,initialIndex,v5Compat:true});}let history=historyRef.current;let[state,setStateImpl]=React.useState({action:history.action,location:history.location});let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{v7_startTransition&&startTransitionImpl?startTransitionImpl(()=>setStateImpl(newState)):setStateImpl(newState);},[setStateImpl,v7_startTransition]);React.useLayoutEffect(()=>history.listen(setState),[history,setState]);return/*#__PURE__*/React.createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */function Navigate(_ref4){let{to,replace,state,relative}=_ref4;!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of\n// the router loaded. We can help them understand how to avoid that.\n\"<Navigate> may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;process.env.NODE_ENV!==\"production\"?UNSAFE_warning(!React.useContext(NavigationContext).static,\"<Navigate> must not be used on the initial render in a <StaticRouter>. \"+\"This is a no-op, but you should modify your code so the <Navigate> is \"+\"only ever rendered in response to some user interaction or state change.\"):void 0;let{matches}=React.useContext(RouteContext);let{pathname:locationPathname}=useLocation();let navigate=useNavigate();// Resolve the path outside of the effect so that when effects run twice in\n// StrictMode they navigate to the same place\nlet path=resolveTo(to,UNSAFE_getPathContributingMatches(matches).map(match=>match.pathnameBase),locationPathname,relative===\"path\");let jsonPath=JSON.stringify(path);React.useEffect(()=>navigate(JSON.parse(jsonPath),{replace,state,relative}),[navigate,jsonPath,relative,replace,state]);return null;}/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */function Outlet(props){return useOutlet(props.context);}/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */function Route(_props){process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"A <Route> is only ever to be used as the child of <Routes> element, \"+\"never rendered directly. Please wrap your <Route> in a <Routes>.\"):UNSAFE_invariant(false);}/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */function Router(_ref5){let{basename:basenameProp=\"/\",children=null,location:locationProp,navigationType=Action.Pop,navigator,static:staticProp=false}=_ref5;!!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"You cannot render a <Router> inside another <Router>.\"+\" You should never have more than one in your app.\"):UNSAFE_invariant(false):void 0;// Preserve trailing slashes on basename, so we can let the user control\n// the enforcement of trailing slashes throughout the app\nlet basename=basenameProp.replace(/^\\/*/,\"/\");let navigationContext=React.useMemo(()=>({basename,navigator,static:staticProp}),[basename,navigator,staticProp]);if(typeof locationProp===\"string\"){locationProp=parsePath(locationProp);}let{pathname=\"/\",search=\"\",hash=\"\",state=null,key=\"default\"}=locationProp;let locationContext=React.useMemo(()=>{let trailingPathname=stripBasename(pathname,basename);if(trailingPathname==null){return null;}return{location:{pathname:trailingPathname,search,hash,state,key},navigationType};},[basename,pathname,search,hash,state,key,navigationType]);process.env.NODE_ENV!==\"production\"?UNSAFE_warning(locationContext!=null,\"<Router basename=\\\"\"+basename+\"\\\"> is not able to match the URL \"+(\"\\\"\"+pathname+search+hash+\"\\\" because it does not start with the \")+\"basename, so the <Router> won't render anything.\"):void 0;if(locationContext==null){return null;}return/*#__PURE__*/React.createElement(NavigationContext.Provider,{value:navigationContext},/*#__PURE__*/React.createElement(LocationContext.Provider,{children:children,value:locationContext}));}/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */function Routes(_ref6){let{children,location}=_ref6;return useRoutes(createRoutesFromChildren(children),location);}/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */function Await(_ref7){let{children,errorElement,resolve}=_ref7;return/*#__PURE__*/React.createElement(AwaitErrorBoundary,{resolve:resolve,errorElement:errorElement},/*#__PURE__*/React.createElement(ResolveAwait,null,children));}var AwaitRenderStatus=/*#__PURE__*/function(AwaitRenderStatus){AwaitRenderStatus[AwaitRenderStatus[\"pending\"]=0]=\"pending\";AwaitRenderStatus[AwaitRenderStatus[\"success\"]=1]=\"success\";AwaitRenderStatus[AwaitRenderStatus[\"error\"]=2]=\"error\";return AwaitRenderStatus;}(AwaitRenderStatus||{});const neverSettledPromise=new Promise(()=>{});class AwaitErrorBoundary extends React.Component{constructor(props){super(props);this.state={error:null};}static getDerivedStateFromError(error){return{error};}componentDidCatch(error,errorInfo){console.error(\"<Await> caught the following error during render\",error,errorInfo);}render(){let{children,errorElement,resolve}=this.props;let promise=null;let status=AwaitRenderStatus.pending;if(!(resolve instanceof Promise)){// Didn't get a promise - provide as a resolved promise\nstatus=AwaitRenderStatus.success;promise=Promise.resolve();Object.defineProperty(promise,\"_tracked\",{get:()=>true});Object.defineProperty(promise,\"_data\",{get:()=>resolve});}else if(this.state.error){// Caught a render error, provide it as a rejected promise\nstatus=AwaitRenderStatus.error;let renderError=this.state.error;promise=Promise.reject().catch(()=>{});// Avoid unhandled rejection warnings\nObject.defineProperty(promise,\"_tracked\",{get:()=>true});Object.defineProperty(promise,\"_error\",{get:()=>renderError});}else if(resolve._tracked){// Already tracked promise - check contents\npromise=resolve;status=promise._error!==undefined?AwaitRenderStatus.error:promise._data!==undefined?AwaitRenderStatus.success:AwaitRenderStatus.pending;}else{// Raw (untracked) promise - track it\nstatus=AwaitRenderStatus.pending;Object.defineProperty(resolve,\"_tracked\",{get:()=>true});promise=resolve.then(data=>Object.defineProperty(resolve,\"_data\",{get:()=>data}),error=>Object.defineProperty(resolve,\"_error\",{get:()=>error}));}if(status===AwaitRenderStatus.error&&promise._error instanceof AbortedDeferredError){// Freeze the UI by throwing a never resolved promise\nthrow neverSettledPromise;}if(status===AwaitRenderStatus.error&&!errorElement){// No errorElement, throw to the nearest route-level error boundary\nthrow promise._error;}if(status===AwaitRenderStatus.error){// Render via our errorElement\nreturn/*#__PURE__*/React.createElement(AwaitContext.Provider,{value:promise,children:errorElement});}if(status===AwaitRenderStatus.success){// Render children with resolved value\nreturn/*#__PURE__*/React.createElement(AwaitContext.Provider,{value:promise,children:children});}// Throw to the suspense boundary\nthrow promise;}}/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */function ResolveAwait(_ref8){let{children}=_ref8;let data=useAsyncValue();let toRender=typeof children===\"function\"?children(data):children;return/*#__PURE__*/React.createElement(React.Fragment,null,toRender);}///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */function createRoutesFromChildren(children,parentPath){if(parentPath===void 0){parentPath=[];}let routes=[];React.Children.forEach(children,(element,index)=>{if(!/*#__PURE__*/React.isValidElement(element)){// Ignore non-elements. This allows people to more easily inline\n// conditionals in their route config.\nreturn;}let treePath=[...parentPath,index];if(element.type===React.Fragment){// Transparently support React.Fragment and its children.\nroutes.push.apply(routes,createRoutesFromChildren(element.props.children,treePath));return;}!(element.type===Route)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"[\"+(typeof element.type===\"string\"?element.type:element.type.name)+\"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\"):UNSAFE_invariant(false):void 0;!(!element.props.index||!element.props.children)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"An index route cannot have child routes.\"):UNSAFE_invariant(false):void 0;let route={id:element.props.id||treePath.join(\"-\"),caseSensitive:element.props.caseSensitive,element:element.props.element,Component:element.props.Component,index:element.props.index,path:element.props.path,loader:element.props.loader,action:element.props.action,errorElement:element.props.errorElement,ErrorBoundary:element.props.ErrorBoundary,hasErrorBoundary:element.props.ErrorBoundary!=null||element.props.errorElement!=null,shouldRevalidate:element.props.shouldRevalidate,handle:element.props.handle,lazy:element.props.lazy};if(element.props.children){route.children=createRoutesFromChildren(element.props.children,treePath);}routes.push(route);});return routes;}/**\n * Renders the result of `matchRoutes()` into a React element.\n */function renderMatches(matches){return _renderMatches(matches);}function mapRouteProperties(route){let updates={// Note: this check also occurs in createRoutesFromChildren so update\n// there if you change this -- please and thank you!\nhasErrorBoundary:route.ErrorBoundary!=null||route.errorElement!=null};if(route.Component){if(process.env.NODE_ENV!==\"production\"){if(route.element){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,\"You should not include both `Component` and `element` on your route - \"+\"`Component` will be used.\"):void 0;}}Object.assign(updates,{element:/*#__PURE__*/React.createElement(route.Component),Component:undefined});}if(route.ErrorBoundary){if(process.env.NODE_ENV!==\"production\"){if(route.errorElement){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,\"You should not include both `ErrorBoundary` and `errorElement` on your route - \"+\"`ErrorBoundary` will be used.\"):void 0;}}Object.assign(updates,{errorElement:/*#__PURE__*/React.createElement(route.ErrorBoundary),ErrorBoundary:undefined});}return updates;}function createMemoryRouter(routes,opts){return createRouter({basename:opts==null?void 0:opts.basename,future:_extends({},opts==null?void 0:opts.future,{v7_prependBasename:true}),history:createMemoryHistory({initialEntries:opts==null?void 0:opts.initialEntries,initialIndex:opts==null?void 0:opts.initialIndex}),hydrationData:opts==null?void 0:opts.hydrationData,routes,mapRouteProperties}).initialize();}export{Await,MemoryRouter,Navigate,Outlet,Route,Router,RouterProvider,Routes,DataRouterContext as UNSAFE_DataRouterContext,DataRouterStateContext as UNSAFE_DataRouterStateContext,LocationContext as UNSAFE_LocationContext,NavigationContext as UNSAFE_NavigationContext,RouteContext as UNSAFE_RouteContext,mapRouteProperties as UNSAFE_mapRouteProperties,useRouteId as UNSAFE_useRouteId,useRoutesImpl as UNSAFE_useRoutesImpl,createMemoryRouter,createRoutesFromChildren,createRoutesFromChildren as createRoutesFromElements,renderMatches,useActionData,useAsyncError,useAsyncValue,useBlocker,useHref,useInRouterContext,useLoaderData,useLocation,useMatch,useMatches,useNavigate,useNavigation,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRevalidator,useRouteError,useRouteLoaderData,useRoutes};","/**\n * @remix-run/router v1.13.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */function _extends(){_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */var Action;(function(Action){/**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */Action[\"Pop\"]=\"POP\";/**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */Action[\"Push\"]=\"PUSH\";/**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */Action[\"Replace\"]=\"REPLACE\";})(Action||(Action={}));const PopStateEventType=\"popstate\";/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */function createMemoryHistory(options){if(options===void 0){options={};}let{initialEntries=[\"/\"],initialIndex,v5Compat=false}=options;let entries;// Declare so we can access from createMemoryLocation\nentries=initialEntries.map((entry,index)=>createMemoryLocation(entry,typeof entry===\"string\"?null:entry.state,index===0?\"default\":undefined));let index=clampIndex(initialIndex==null?entries.length-1:initialIndex);let action=Action.Pop;let listener=null;function clampIndex(n){return Math.min(Math.max(n,0),entries.length-1);}function getCurrentLocation(){return entries[index];}function createMemoryLocation(to,state,key){if(state===void 0){state=null;}let location=createLocation(entries?getCurrentLocation().pathname:\"/\",to,state,key);warning(location.pathname.charAt(0)===\"/\",\"relative pathnames are not supported in memory history: \"+JSON.stringify(to));return location;}function createHref(to){return typeof to===\"string\"?to:createPath(to);}let history={get index(){return index;},get action(){return action;},get location(){return getCurrentLocation();},createHref,createURL(to){return new URL(createHref(to),\"http://localhost\");},encodeLocation(to){let path=typeof to===\"string\"?parsePath(to):to;return{pathname:path.pathname||\"\",search:path.search||\"\",hash:path.hash||\"\"};},push(to,state){action=Action.Push;let nextLocation=createMemoryLocation(to,state);index+=1;entries.splice(index,entries.length,nextLocation);if(v5Compat&&listener){listener({action,location:nextLocation,delta:1});}},replace(to,state){action=Action.Replace;let nextLocation=createMemoryLocation(to,state);entries[index]=nextLocation;if(v5Compat&&listener){listener({action,location:nextLocation,delta:0});}},go(delta){action=Action.Pop;let nextIndex=clampIndex(index+delta);let nextLocation=entries[nextIndex];index=nextIndex;if(listener){listener({action,location:nextLocation,delta});}},listen(fn){listener=fn;return()=>{listener=null;};}};return history;}/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */function createBrowserHistory(options){if(options===void 0){options={};}function createBrowserLocation(window,globalHistory){let{pathname,search,hash}=window.location;return createLocation(\"\",{pathname,search,hash},// state defaults to `null` because `window.history.state` does\nglobalHistory.state&&globalHistory.state.usr||null,globalHistory.state&&globalHistory.state.key||\"default\");}function createBrowserHref(window,to){return typeof to===\"string\"?to:createPath(to);}return getUrlBasedHistory(createBrowserLocation,createBrowserHref,null,options);}/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */function createHashHistory(options){if(options===void 0){options={};}function createHashLocation(window,globalHistory){let{pathname=\"/\",search=\"\",hash=\"\"}=parsePath(window.location.hash.substr(1));// Hash URL should always have a leading / just like window.location.pathname\n// does, so if an app ends up at a route like /#something then we add a\n// leading slash so all of our path-matching behaves the same as if it would\n// in a browser router.  This is particularly important when there exists a\n// root splat route (<Route path=\"*\">) since that matches internally against\n// \"/*\" and we'd expect /#something to 404 in a hash router app.\nif(!pathname.startsWith(\"/\")&&!pathname.startsWith(\".\")){pathname=\"/\"+pathname;}return createLocation(\"\",{pathname,search,hash},// state defaults to `null` because `window.history.state` does\nglobalHistory.state&&globalHistory.state.usr||null,globalHistory.state&&globalHistory.state.key||\"default\");}function createHashHref(window,to){let base=window.document.querySelector(\"base\");let href=\"\";if(base&&base.getAttribute(\"href\")){let url=window.location.href;let hashIndex=url.indexOf(\"#\");href=hashIndex===-1?url:url.slice(0,hashIndex);}return href+\"#\"+(typeof to===\"string\"?to:createPath(to));}function validateHashLocation(location,to){warning(location.pathname.charAt(0)===\"/\",\"relative pathnames are not supported in hash history.push(\"+JSON.stringify(to)+\")\");}return getUrlBasedHistory(createHashLocation,createHashHref,validateHashLocation,options);}function invariant(value,message){if(value===false||value===null||typeof value===\"undefined\"){throw new Error(message);}}function warning(cond,message){if(!cond){// eslint-disable-next-line no-console\nif(typeof console!==\"undefined\")console.warn(message);try{// Welcome to debugging history!\n//\n// This error is thrown as a convenience, so you can more easily\n// find the source for a warning that appears in the console by\n// enabling \"pause on exceptions\" in your JavaScript debugger.\nthrow new Error(message);// eslint-disable-next-line no-empty\n}catch(e){}}}function createKey(){return Math.random().toString(36).substr(2,8);}/**\n * For browser-based histories, we combine the state and key into an object\n */function getHistoryState(location,index){return{usr:location.state,key:location.key,idx:index};}/**\n * Creates a Location object with a unique key from the given Path\n */function createLocation(current,to,state,key){if(state===void 0){state=null;}let location=_extends({pathname:typeof current===\"string\"?current:current.pathname,search:\"\",hash:\"\"},typeof to===\"string\"?parsePath(to):to,{state,// TODO: This could be cleaned up.  push/replace should probably just take\n// full Locations now and avoid the need to run through this flow at all\n// But that's a pretty big refactor to the current test suite so going to\n// keep as is for the time being and just let any incoming keys take precedence\nkey:to&&to.key||key||createKey()});return location;}/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */function createPath(_ref){let{pathname=\"/\",search=\"\",hash=\"\"}=_ref;if(search&&search!==\"?\")pathname+=search.charAt(0)===\"?\"?search:\"?\"+search;if(hash&&hash!==\"#\")pathname+=hash.charAt(0)===\"#\"?hash:\"#\"+hash;return pathname;}/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */function parsePath(path){let parsedPath={};if(path){let hashIndex=path.indexOf(\"#\");if(hashIndex>=0){parsedPath.hash=path.substr(hashIndex);path=path.substr(0,hashIndex);}let searchIndex=path.indexOf(\"?\");if(searchIndex>=0){parsedPath.search=path.substr(searchIndex);path=path.substr(0,searchIndex);}if(path){parsedPath.pathname=path;}}return parsedPath;}function getUrlBasedHistory(getLocation,createHref,validateLocation,options){if(options===void 0){options={};}let{window=document.defaultView,v5Compat=false}=options;let globalHistory=window.history;let action=Action.Pop;let listener=null;let index=getIndex();// Index should only be null when we initialize. If not, it's because the\n// user called history.pushState or history.replaceState directly, in which\n// case we should log a warning as it will result in bugs.\nif(index==null){index=0;globalHistory.replaceState(_extends({},globalHistory.state,{idx:index}),\"\");}function getIndex(){let state=globalHistory.state||{idx:null};return state.idx;}function handlePop(){action=Action.Pop;let nextIndex=getIndex();let delta=nextIndex==null?null:nextIndex-index;index=nextIndex;if(listener){listener({action,location:history.location,delta});}}function push(to,state){action=Action.Push;let location=createLocation(history.location,to,state);if(validateLocation)validateLocation(location,to);index=getIndex()+1;let historyState=getHistoryState(location,index);let url=history.createHref(location);// try...catch because iOS limits us to 100 pushState calls :/\ntry{globalHistory.pushState(historyState,\"\",url);}catch(error){// If the exception is because `state` can't be serialized, let that throw\n// outwards just like a replace call would so the dev knows the cause\n// https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n// https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\nif(error instanceof DOMException&&error.name===\"DataCloneError\"){throw error;}// They are going to lose state here, but there is no real\n// way to warn them about it since the page will refresh...\nwindow.location.assign(url);}if(v5Compat&&listener){listener({action,location:history.location,delta:1});}}function replace(to,state){action=Action.Replace;let location=createLocation(history.location,to,state);if(validateLocation)validateLocation(location,to);index=getIndex();let historyState=getHistoryState(location,index);let url=history.createHref(location);globalHistory.replaceState(historyState,\"\",url);if(v5Compat&&listener){listener({action,location:history.location,delta:0});}}function createURL(to){// window.location.origin is \"null\" (the literal string value) in Firefox\n// under certain conditions, notably when serving from a local HTML file\n// See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\nlet base=window.location.origin!==\"null\"?window.location.origin:window.location.href;let href=typeof to===\"string\"?to:createPath(to);invariant(base,\"No window.location.(origin|href) available to create URL for href: \"+href);return new URL(href,base);}let history={get action(){return action;},get location(){return getLocation(window,globalHistory);},listen(fn){if(listener){throw new Error(\"A history only accepts one active listener\");}window.addEventListener(PopStateEventType,handlePop);listener=fn;return()=>{window.removeEventListener(PopStateEventType,handlePop);listener=null;};},createHref(to){return createHref(window,to);},createURL,encodeLocation(to){// Encode a Location the same way window.location would\nlet url=createURL(to);return{pathname:url.pathname,search:url.search,hash:url.hash};},push,replace,go(n){return globalHistory.go(n);}};return history;}//#endregion\nvar ResultType;(function(ResultType){ResultType[\"data\"]=\"data\";ResultType[\"deferred\"]=\"deferred\";ResultType[\"redirect\"]=\"redirect\";ResultType[\"error\"]=\"error\";})(ResultType||(ResultType={}));const immutableRouteKeys=new Set([\"lazy\",\"caseSensitive\",\"path\",\"id\",\"index\",\"children\"]);function isIndexRoute(route){return route.index===true;}// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes,mapRouteProperties,parentPath,manifest){if(parentPath===void 0){parentPath=[];}if(manifest===void 0){manifest={};}return routes.map((route,index)=>{let treePath=[...parentPath,index];let id=typeof route.id===\"string\"?route.id:treePath.join(\"-\");invariant(route.index!==true||!route.children,\"Cannot specify children on an index route\");invariant(!manifest[id],\"Found a route id collision on id \\\"\"+id+\"\\\".  Route \"+\"id's must be globally unique within Data Router usages\");if(isIndexRoute(route)){let indexRoute=_extends({},route,mapRouteProperties(route),{id});manifest[id]=indexRoute;return indexRoute;}else{let pathOrLayoutRoute=_extends({},route,mapRouteProperties(route),{id,children:undefined});manifest[id]=pathOrLayoutRoute;if(route.children){pathOrLayoutRoute.children=convertRoutesToDataRoutes(route.children,mapRouteProperties,treePath,manifest);}return pathOrLayoutRoute;}});}/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */function matchRoutes(routes,locationArg,basename){if(basename===void 0){basename=\"/\";}let location=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;let pathname=stripBasename(location.pathname||\"/\",basename);if(pathname==null){return null;}let branches=flattenRoutes(routes);rankRouteBranches(branches);let matches=null;for(let i=0;matches==null&&i<branches.length;++i){matches=matchRouteBranch(branches[i],// Incoming pathnames are generally encoded from either window.location\n// or from router.navigate, but we want to match against the unencoded\n// paths in the route definitions.  Memory router locations won't be\n// encoded here but there also shouldn't be anything to decode so this\n// should be a safe operation.  This avoids needing matchRoutes to be\n// history-aware.\nsafelyDecodeURI(pathname));}return matches;}function convertRouteMatchToUiMatch(match,loaderData){let{route,pathname,params}=match;return{id:route.id,pathname,params,data:loaderData[route.id],handle:route.handle};}function flattenRoutes(routes,branches,parentsMeta,parentPath){if(branches===void 0){branches=[];}if(parentsMeta===void 0){parentsMeta=[];}if(parentPath===void 0){parentPath=\"\";}let flattenRoute=(route,index,relativePath)=>{let meta={relativePath:relativePath===undefined?route.path||\"\":relativePath,caseSensitive:route.caseSensitive===true,childrenIndex:index,route};if(meta.relativePath.startsWith(\"/\")){invariant(meta.relativePath.startsWith(parentPath),\"Absolute route path \\\"\"+meta.relativePath+\"\\\" nested under path \"+(\"\\\"\"+parentPath+\"\\\" is not valid. An absolute child route path \")+\"must start with the combined path of all its parent routes.\");meta.relativePath=meta.relativePath.slice(parentPath.length);}let path=joinPaths([parentPath,meta.relativePath]);let routesMeta=parentsMeta.concat(meta);// Add the children before adding this route to the array, so we traverse the\n// route tree depth-first and child routes appear before their parents in\n// the \"flattened\" version.\nif(route.children&&route.children.length>0){invariant(// Our types know better, but runtime JS may not!\n// @ts-expect-error\nroute.index!==true,\"Index routes must not have child routes. Please remove \"+(\"all child routes from route path \\\"\"+path+\"\\\".\"));flattenRoutes(route.children,branches,routesMeta,path);}// Routes without a path shouldn't ever match by themselves unless they are\n// index routes, so don't add them to the list of possible branches.\nif(route.path==null&&!route.index){return;}branches.push({path,score:computeScore(path,route.index),routesMeta});};routes.forEach((route,index)=>{var _route$path;// coarse-grain check for optional params\nif(route.path===\"\"||!((_route$path=route.path)!=null&&_route$path.includes(\"?\"))){flattenRoute(route,index);}else{for(let exploded of explodeOptionalSegments(route.path)){flattenRoute(route,index,exploded);}}});return branches;}/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */function explodeOptionalSegments(path){let segments=path.split(\"/\");if(segments.length===0)return[];let[first,...rest]=segments;// Optional path segments are denoted by a trailing `?`\nlet isOptional=first.endsWith(\"?\");// Compute the corresponding required segment: `foo?` -> `foo`\nlet required=first.replace(/\\?$/,\"\");if(rest.length===0){// Intepret empty string as omitting an optional segment\n// `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\nreturn isOptional?[required,\"\"]:[required];}let restExploded=explodeOptionalSegments(rest.join(\"/\"));let result=[];// All child paths with the prefix.  Do this for all children before the\n// optional version for all children, so we get consistent ordering where the\n// parent optional aspect is preferred as required.  Otherwise, we can get\n// child sections interspersed where deeper optional segments are higher than\n// parent optional segments, where for example, /:two would explode _earlier_\n// then /:one.  By always including the parent as required _for all children_\n// first, we avoid this issue\nresult.push(...restExploded.map(subpath=>subpath===\"\"?required:[required,subpath].join(\"/\")));// Then, if this is an optional value, add all child versions without\nif(isOptional){result.push(...restExploded);}// for absolute paths, ensure `/` instead of empty segment\nreturn result.map(exploded=>path.startsWith(\"/\")&&exploded===\"\"?\"/\":exploded);}function rankRouteBranches(branches){branches.sort((a,b)=>a.score!==b.score?b.score-a.score// Higher score first\n:compareIndexes(a.routesMeta.map(meta=>meta.childrenIndex),b.routesMeta.map(meta=>meta.childrenIndex)));}const paramRe=/^:\\w+$/;const dynamicSegmentValue=3;const indexRouteValue=2;const emptySegmentValue=1;const staticSegmentValue=10;const splatPenalty=-2;const isSplat=s=>s===\"*\";function computeScore(path,index){let segments=path.split(\"/\");let initialScore=segments.length;if(segments.some(isSplat)){initialScore+=splatPenalty;}if(index){initialScore+=indexRouteValue;}return segments.filter(s=>!isSplat(s)).reduce((score,segment)=>score+(paramRe.test(segment)?dynamicSegmentValue:segment===\"\"?emptySegmentValue:staticSegmentValue),initialScore);}function compareIndexes(a,b){let siblings=a.length===b.length&&a.slice(0,-1).every((n,i)=>n===b[i]);return siblings?// If two routes are siblings, we should try to match the earlier sibling\n// first. This allows people to have fine-grained control over the matching\n// behavior by simply putting routes with identical paths in the order they\n// want them tried.\na[a.length-1]-b[b.length-1]:// Otherwise, it doesn't really make sense to rank non-siblings by index,\n// so they sort equally.\n0;}function matchRouteBranch(branch,pathname){let{routesMeta}=branch;let matchedParams={};let matchedPathname=\"/\";let matches=[];for(let i=0;i<routesMeta.length;++i){let meta=routesMeta[i];let end=i===routesMeta.length-1;let remainingPathname=matchedPathname===\"/\"?pathname:pathname.slice(matchedPathname.length)||\"/\";let match=matchPath({path:meta.relativePath,caseSensitive:meta.caseSensitive,end},remainingPathname);if(!match)return null;Object.assign(matchedParams,match.params);let route=meta.route;matches.push({// TODO: Can this as be avoided?\nparams:matchedParams,pathname:joinPaths([matchedPathname,match.pathname]),pathnameBase:normalizePathname(joinPaths([matchedPathname,match.pathnameBase])),route});if(match.pathnameBase!==\"/\"){matchedPathname=joinPaths([matchedPathname,match.pathnameBase]);}}return matches;}/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */function generatePath(originalPath,params){if(params===void 0){params={};}let path=originalPath;if(path.endsWith(\"*\")&&path!==\"*\"&&!path.endsWith(\"/*\")){warning(false,\"Route path \\\"\"+path+\"\\\" will be treated as if it were \"+(\"\\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\" because the `*` character must \")+\"always follow a `/` in the pattern. To get rid of this warning, \"+(\"please change the route path to \\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\".\"));path=path.replace(/\\*$/,\"/*\");}// ensure `/` is added at the beginning if the path is absolute\nconst prefix=path.startsWith(\"/\")?\"/\":\"\";const stringify=p=>p==null?\"\":typeof p===\"string\"?p:String(p);const segments=path.split(/\\/+/).map((segment,index,array)=>{const isLastSegment=index===array.length-1;// only apply the splat if it's the last segment\nif(isLastSegment&&segment===\"*\"){const star=\"*\";// Apply the splat\nreturn stringify(params[star]);}const keyMatch=segment.match(/^:(\\w+)(\\??)$/);if(keyMatch){const[,key,optional]=keyMatch;let param=params[key];invariant(optional===\"?\"||param!=null,\"Missing \\\":\"+key+\"\\\" param\");return stringify(param);}// Remove any optional markers from optional static segments\nreturn segment.replace(/\\?$/g,\"\");})// Remove empty segments\n.filter(segment=>!!segment);return prefix+segments.join(\"/\");}/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */function matchPath(pattern,pathname){if(typeof pattern===\"string\"){pattern={path:pattern,caseSensitive:false,end:true};}let[matcher,compiledParams]=compilePath(pattern.path,pattern.caseSensitive,pattern.end);let match=pathname.match(matcher);if(!match)return null;let matchedPathname=match[0];let pathnameBase=matchedPathname.replace(/(.)\\/+$/,\"$1\");let captureGroups=match.slice(1);let params=compiledParams.reduce((memo,_ref,index)=>{let{paramName,isOptional}=_ref;// We need to compute the pathnameBase here using the raw splat value\n// instead of using params[\"*\"] later because it will be decoded then\nif(paramName===\"*\"){let splatValue=captureGroups[index]||\"\";pathnameBase=matchedPathname.slice(0,matchedPathname.length-splatValue.length).replace(/(.)\\/+$/,\"$1\");}const value=captureGroups[index];if(isOptional&&!value){memo[paramName]=undefined;}else{memo[paramName]=safelyDecodeURIComponent(value||\"\",paramName);}return memo;},{});return{params,pathname:matchedPathname,pathnameBase,pattern};}function compilePath(path,caseSensitive,end){if(caseSensitive===void 0){caseSensitive=false;}if(end===void 0){end=true;}warning(path===\"*\"||!path.endsWith(\"*\")||path.endsWith(\"/*\"),\"Route path \\\"\"+path+\"\\\" will be treated as if it were \"+(\"\\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\" because the `*` character must \")+\"always follow a `/` in the pattern. To get rid of this warning, \"+(\"please change the route path to \\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\".\"));let params=[];let regexpSource=\"^\"+path.replace(/\\/*\\*?$/,\"\")// Ignore trailing / and /*, we'll handle it below\n.replace(/^\\/*/,\"/\")// Make sure it has a leading /\n.replace(/[\\\\.*+^${}|()[\\]]/g,\"\\\\$&\")// Escape special regex chars\n.replace(/\\/:(\\w+)(\\?)?/g,(_,paramName,isOptional)=>{params.push({paramName,isOptional:isOptional!=null});return isOptional?\"/?([^\\\\/]+)?\":\"/([^\\\\/]+)\";});if(path.endsWith(\"*\")){params.push({paramName:\"*\"});regexpSource+=path===\"*\"||path===\"/*\"?\"(.*)$\"// Already matched the initial /, just match the rest\n:\"(?:\\\\/(.+)|\\\\/*)$\";// Don't include the / in params[\"*\"]\n}else if(end){// When matching to the end, ignore trailing slashes\nregexpSource+=\"\\\\/*$\";}else if(path!==\"\"&&path!==\"/\"){// If our path is non-empty and contains anything beyond an initial slash,\n// then we have _some_ form of path in our regex, so we should expect to\n// match only if we find the end of this path segment.  Look for an optional\n// non-captured trailing slash (to match a portion of the URL) or the end\n// of the path (if we've matched to the end).  We used to do this with a\n// word boundary but that gives false positives on routes like\n// /user-preferences since `-` counts as a word boundary.\nregexpSource+=\"(?:(?=\\\\/|$))\";}else;let matcher=new RegExp(regexpSource,caseSensitive?undefined:\"i\");return[matcher,params];}function safelyDecodeURI(value){try{return decodeURI(value);}catch(error){warning(false,\"The URL path \\\"\"+value+\"\\\" could not be decoded because it is is a \"+\"malformed URL segment. This is probably due to a bad percent \"+(\"encoding (\"+error+\").\"));return value;}}function safelyDecodeURIComponent(value,paramName){try{return decodeURIComponent(value);}catch(error){warning(false,\"The value for the URL param \\\"\"+paramName+\"\\\" will not be decoded because\"+(\" the string \\\"\"+value+\"\\\" is a malformed URL segment. This is probably\")+(\" due to a bad percent encoding (\"+error+\").\"));return value;}}/**\n * @private\n */function stripBasename(pathname,basename){if(basename===\"/\")return pathname;if(!pathname.toLowerCase().startsWith(basename.toLowerCase())){return null;}// We want to leave trailing slash behavior in the user's control, so if they\n// specify a basename with a trailing slash, we should support it\nlet startIndex=basename.endsWith(\"/\")?basename.length-1:basename.length;let nextChar=pathname.charAt(startIndex);if(nextChar&&nextChar!==\"/\"){// pathname does not start with basename/\nreturn null;}return pathname.slice(startIndex)||\"/\";}/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */function resolvePath(to,fromPathname){if(fromPathname===void 0){fromPathname=\"/\";}let{pathname:toPathname,search=\"\",hash=\"\"}=typeof to===\"string\"?parsePath(to):to;let pathname=toPathname?toPathname.startsWith(\"/\")?toPathname:resolvePathname(toPathname,fromPathname):fromPathname;return{pathname,search:normalizeSearch(search),hash:normalizeHash(hash)};}function resolvePathname(relativePath,fromPathname){let segments=fromPathname.replace(/\\/+$/,\"\").split(\"/\");let relativeSegments=relativePath.split(\"/\");relativeSegments.forEach(segment=>{if(segment===\"..\"){// Keep the root \"\" segment so the pathname starts at /\nif(segments.length>1)segments.pop();}else if(segment!==\".\"){segments.push(segment);}});return segments.length>1?segments.join(\"/\"):\"/\";}function getInvalidPathError(char,field,dest,path){return\"Cannot include a '\"+char+\"' character in a manually specified \"+(\"`to.\"+field+\"` field [\"+JSON.stringify(path)+\"].  Please separate it out to the \")+(\"`to.\"+dest+\"` field. Alternatively you may provide the full path as \")+\"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";}/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */function getPathContributingMatches(matches){return matches.filter((match,index)=>index===0||match.route.path&&match.route.path.length>0);}/**\n * @private\n */function resolveTo(toArg,routePathnames,locationPathname,isPathRelative){if(isPathRelative===void 0){isPathRelative=false;}let to;if(typeof toArg===\"string\"){to=parsePath(toArg);}else{to=_extends({},toArg);invariant(!to.pathname||!to.pathname.includes(\"?\"),getInvalidPathError(\"?\",\"pathname\",\"search\",to));invariant(!to.pathname||!to.pathname.includes(\"#\"),getInvalidPathError(\"#\",\"pathname\",\"hash\",to));invariant(!to.search||!to.search.includes(\"#\"),getInvalidPathError(\"#\",\"search\",\"hash\",to));}let isEmptyPath=toArg===\"\"||to.pathname===\"\";let toPathname=isEmptyPath?\"/\":to.pathname;let from;// Routing is relative to the current pathname if explicitly requested.\n//\n// If a pathname is explicitly provided in `to`, it should be relative to the\n// route context. This is explained in `Note on `<Link to>` values` in our\n// migration guide from v5 as a means of disambiguation between `to` values\n// that begin with `/` and those that do not. However, this is problematic for\n// `to` values that do not provide a pathname. `to` can simply be a search or\n// hash string, in which case we should assume that the navigation is relative\n// to the current location's pathname and *not* the route pathname.\nif(toPathname==null){from=locationPathname;}else if(isPathRelative){let fromSegments=routePathnames[routePathnames.length-1].replace(/^\\//,\"\").split(\"/\");if(toPathname.startsWith(\"..\")){let toSegments=toPathname.split(\"/\");// With relative=\"path\", each leading .. segment means \"go up one URL segment\"\nwhile(toSegments[0]===\"..\"){toSegments.shift();fromSegments.pop();}to.pathname=toSegments.join(\"/\");}from=\"/\"+fromSegments.join(\"/\");}else{let routePathnameIndex=routePathnames.length-1;if(toPathname.startsWith(\"..\")){let toSegments=toPathname.split(\"/\");// With relative=\"route\" (the default), each leading .. segment means\n// \"go up one route\" instead of \"go up one URL segment\".  This is a key\n// difference from how <a href> works and a major reason we call this a\n// \"to\" value instead of a \"href\".\nwhile(toSegments[0]===\"..\"){toSegments.shift();routePathnameIndex-=1;}to.pathname=toSegments.join(\"/\");}// If there are more \"..\" segments than parent routes, resolve relative to\n// the root / URL.\nfrom=routePathnameIndex>=0?routePathnames[routePathnameIndex]:\"/\";}let path=resolvePath(to,from);// Ensure the pathname has a trailing slash if the original \"to\" had one\nlet hasExplicitTrailingSlash=toPathname&&toPathname!==\"/\"&&toPathname.endsWith(\"/\");// Or if this was a link to the current path which has a trailing slash\nlet hasCurrentTrailingSlash=(isEmptyPath||toPathname===\".\")&&locationPathname.endsWith(\"/\");if(!path.pathname.endsWith(\"/\")&&(hasExplicitTrailingSlash||hasCurrentTrailingSlash)){path.pathname+=\"/\";}return path;}/**\n * @private\n */function getToPathname(to){// Empty strings should be treated the same as / paths\nreturn to===\"\"||to.pathname===\"\"?\"/\":typeof to===\"string\"?parsePath(to).pathname:to.pathname;}/**\n * @private\n */const joinPaths=paths=>paths.join(\"/\").replace(/\\/\\/+/g,\"/\");/**\n * @private\n */const normalizePathname=pathname=>pathname.replace(/\\/+$/,\"\").replace(/^\\/*/,\"/\");/**\n * @private\n */const normalizeSearch=search=>!search||search===\"?\"?\"\":search.startsWith(\"?\")?search:\"?\"+search;/**\n * @private\n */const normalizeHash=hash=>!hash||hash===\"#\"?\"\":hash.startsWith(\"#\")?hash:\"#\"+hash;/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */const json=function json(data,init){if(init===void 0){init={};}let responseInit=typeof init===\"number\"?{status:init}:init;let headers=new Headers(responseInit.headers);if(!headers.has(\"Content-Type\")){headers.set(\"Content-Type\",\"application/json; charset=utf-8\");}return new Response(JSON.stringify(data),_extends({},responseInit,{headers}));};class AbortedDeferredError extends Error{}class DeferredData{constructor(data,responseInit){this.pendingKeysSet=new Set();this.subscribers=new Set();this.deferredKeys=[];invariant(data&&typeof data===\"object\"&&!Array.isArray(data),\"defer() only accepts plain objects\");// Set up an AbortController + Promise we can race against to exit early\n// cancellation\nlet reject;this.abortPromise=new Promise((_,r)=>reject=r);this.controller=new AbortController();let onAbort=()=>reject(new AbortedDeferredError(\"Deferred data aborted\"));this.unlistenAbortSignal=()=>this.controller.signal.removeEventListener(\"abort\",onAbort);this.controller.signal.addEventListener(\"abort\",onAbort);this.data=Object.entries(data).reduce((acc,_ref2)=>{let[key,value]=_ref2;return Object.assign(acc,{[key]:this.trackPromise(key,value)});},{});if(this.done){// All incoming values were resolved\nthis.unlistenAbortSignal();}this.init=responseInit;}trackPromise(key,value){if(!(value instanceof Promise)){return value;}this.deferredKeys.push(key);this.pendingKeysSet.add(key);// We store a little wrapper promise that will be extended with\n// _data/_error props upon resolve/reject\nlet promise=Promise.race([value,this.abortPromise]).then(data=>this.onSettle(promise,key,undefined,data),error=>this.onSettle(promise,key,error));// Register rejection listeners to avoid uncaught promise rejections on\n// errors or aborted deferred values\npromise.catch(()=>{});Object.defineProperty(promise,\"_tracked\",{get:()=>true});return promise;}onSettle(promise,key,error,data){if(this.controller.signal.aborted&&error instanceof AbortedDeferredError){this.unlistenAbortSignal();Object.defineProperty(promise,\"_error\",{get:()=>error});return Promise.reject(error);}this.pendingKeysSet.delete(key);if(this.done){// Nothing left to abort!\nthis.unlistenAbortSignal();}// If the promise was resolved/rejected with undefined, we'll throw an error as you\n// should always resolve with a value or null\nif(error===undefined&&data===undefined){let undefinedError=new Error(\"Deferred data for key \\\"\"+key+\"\\\" resolved/rejected with `undefined`, \"+\"you must resolve/reject with a value or `null`.\");Object.defineProperty(promise,\"_error\",{get:()=>undefinedError});this.emit(false,key);return Promise.reject(undefinedError);}if(data===undefined){Object.defineProperty(promise,\"_error\",{get:()=>error});this.emit(false,key);return Promise.reject(error);}Object.defineProperty(promise,\"_data\",{get:()=>data});this.emit(false,key);return data;}emit(aborted,settledKey){this.subscribers.forEach(subscriber=>subscriber(aborted,settledKey));}subscribe(fn){this.subscribers.add(fn);return()=>this.subscribers.delete(fn);}cancel(){this.controller.abort();this.pendingKeysSet.forEach((v,k)=>this.pendingKeysSet.delete(k));this.emit(true);}async resolveData(signal){let aborted=false;if(!this.done){let onAbort=()=>this.cancel();signal.addEventListener(\"abort\",onAbort);aborted=await new Promise(resolve=>{this.subscribe(aborted=>{signal.removeEventListener(\"abort\",onAbort);if(aborted||this.done){resolve(aborted);}});});}return aborted;}get done(){return this.pendingKeysSet.size===0;}get unwrappedData(){invariant(this.data!==null&&this.done,\"Can only unwrap data on initialized and settled deferreds\");return Object.entries(this.data).reduce((acc,_ref3)=>{let[key,value]=_ref3;return Object.assign(acc,{[key]:unwrapTrackedPromise(value)});},{});}get pendingKeys(){return Array.from(this.pendingKeysSet);}}function isTrackedPromise(value){return value instanceof Promise&&value._tracked===true;}function unwrapTrackedPromise(value){if(!isTrackedPromise(value)){return value;}if(value._error){throw value._error;}return value._data;}const defer=function defer(data,init){if(init===void 0){init={};}let responseInit=typeof init===\"number\"?{status:init}:init;return new DeferredData(data,responseInit);};/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */const redirect=function redirect(url,init){if(init===void 0){init=302;}let responseInit=init;if(typeof responseInit===\"number\"){responseInit={status:responseInit};}else if(typeof responseInit.status===\"undefined\"){responseInit.status=302;}let headers=new Headers(responseInit.headers);headers.set(\"Location\",url);return new Response(null,_extends({},responseInit,{headers}));};/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */const redirectDocument=(url,init)=>{let response=redirect(url,init);response.headers.set(\"X-Remix-Reload-Document\",\"true\");return response;};/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */class ErrorResponseImpl{constructor(status,statusText,data,internal){if(internal===void 0){internal=false;}this.status=status;this.statusText=statusText||\"\";this.internal=internal;if(data instanceof Error){this.data=data.toString();this.error=data;}else{this.data=data;}}}/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */function isRouteErrorResponse(error){return error!=null&&typeof error.status===\"number\"&&typeof error.statusText===\"string\"&&typeof error.internal===\"boolean\"&&\"data\"in error;}const validMutationMethodsArr=[\"post\",\"put\",\"patch\",\"delete\"];const validMutationMethods=new Set(validMutationMethodsArr);const validRequestMethodsArr=[\"get\",...validMutationMethodsArr];const validRequestMethods=new Set(validRequestMethodsArr);const redirectStatusCodes=new Set([301,302,303,307,308]);const redirectPreserveMethodStatusCodes=new Set([307,308]);const IDLE_NAVIGATION={state:\"idle\",location:undefined,formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined};const IDLE_FETCHER={state:\"idle\",data:undefined,formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined};const IDLE_BLOCKER={state:\"unblocked\",proceed:undefined,reset:undefined,location:undefined};const ABSOLUTE_URL_REGEX=/^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;const defaultMapRouteProperties=route=>({hasErrorBoundary:Boolean(route.hasErrorBoundary)});const TRANSITIONS_STORAGE_KEY=\"remix-router-transitions\";//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */function createRouter(init){const routerWindow=init.window?init.window:typeof window!==\"undefined\"?window:undefined;const isBrowser=typeof routerWindow!==\"undefined\"&&typeof routerWindow.document!==\"undefined\"&&typeof routerWindow.document.createElement!==\"undefined\";const isServer=!isBrowser;invariant(init.routes.length>0,\"You must provide a non-empty routes array to createRouter\");let mapRouteProperties;if(init.mapRouteProperties){mapRouteProperties=init.mapRouteProperties;}else if(init.detectErrorBoundary){// If they are still using the deprecated version, wrap it with the new API\nlet detectErrorBoundary=init.detectErrorBoundary;mapRouteProperties=route=>({hasErrorBoundary:detectErrorBoundary(route)});}else{mapRouteProperties=defaultMapRouteProperties;}// Routes keyed by ID\nlet manifest={};// Routes in tree format for matching\nlet dataRoutes=convertRoutesToDataRoutes(init.routes,mapRouteProperties,undefined,manifest);let inFlightDataRoutes;let basename=init.basename||\"/\";// Config driven behavior flags\nlet future=_extends({v7_fetcherPersist:false,v7_normalizeFormMethod:false,v7_prependBasename:false},init.future);// Cleanup function for history\nlet unlistenHistory=null;// Externally-provided functions to call on all state changes\nlet subscribers=new Set();// Externally-provided object to hold scroll restoration locations during routing\nlet savedScrollPositions=null;// Externally-provided function to get scroll restoration keys\nlet getScrollRestorationKey=null;// Externally-provided function to get current scroll position\nlet getScrollPosition=null;// One-time flag to control the initial hydration scroll restoration.  Because\n// we don't get the saved positions from <ScrollRestoration /> until _after_\n// the initial render, we need to manually trigger a separate updateState to\n// send along the restoreScrollPosition\n// Set to true if we have `hydrationData` since we assume we were SSR'd and that\n// SSR did the initial scroll restoration.\nlet initialScrollRestored=init.hydrationData!=null;let initialMatches=matchRoutes(dataRoutes,init.history.location,basename);let initialErrors=null;if(initialMatches==null){// If we do not match a user-provided-route, fall back to the root\n// to allow the error boundary to take over\nlet error=getInternalRouterError(404,{pathname:init.history.location.pathname});let{matches,route}=getShortCircuitMatches(dataRoutes);initialMatches=matches;initialErrors={[route.id]:error};}let initialized=// All initialMatches need to be loaded before we're ready.  If we have lazy\n// functions around still then we'll need to run them in initialize()\n!initialMatches.some(m=>m.route.lazy)&&(// And we have to either have no loaders or have been provided hydrationData\n!initialMatches.some(m=>m.route.loader)||init.hydrationData!=null);let router;let state={historyAction:init.history.action,location:init.history.location,matches:initialMatches,initialized,navigation:IDLE_NAVIGATION,// Don't restore on initial updateState() if we were SSR'd\nrestoreScrollPosition:init.hydrationData!=null?false:null,preventScrollReset:false,revalidation:\"idle\",loaderData:init.hydrationData&&init.hydrationData.loaderData||{},actionData:init.hydrationData&&init.hydrationData.actionData||null,errors:init.hydrationData&&init.hydrationData.errors||initialErrors,fetchers:new Map(),blockers:new Map()};// -- Stateful internal variables to manage navigations --\n// Current navigation in progress (to be committed in completeNavigation)\nlet pendingAction=Action.Pop;// Should the current navigation prevent the scroll reset if scroll cannot\n// be restored?\nlet pendingPreventScrollReset=false;// AbortController for the active navigation\nlet pendingNavigationController;// Should the current navigation enable document.startViewTransition?\nlet pendingViewTransitionEnabled=false;// Store applied view transitions so we can apply them on POP\nlet appliedViewTransitions=new Map();// Cleanup function for persisting applied transitions to sessionStorage\nlet removePageHideEventListener=null;// We use this to avoid touching history in completeNavigation if a\n// revalidation is entirely uninterrupted\nlet isUninterruptedRevalidation=false;// Use this internal flag to force revalidation of all loaders:\n//  - submissions (completed or interrupted)\n//  - useRevalidator()\n//  - X-Remix-Revalidate (from redirect)\nlet isRevalidationRequired=false;// Use this internal array to capture routes that require revalidation due\n// to a cancelled deferred on action submission\nlet cancelledDeferredRoutes=[];// Use this internal array to capture fetcher loads that were cancelled by an\n// action navigation and require revalidation\nlet cancelledFetcherLoads=[];// AbortControllers for any in-flight fetchers\nlet fetchControllers=new Map();// Track loads based on the order in which they started\nlet incrementingLoadId=0;// Track the outstanding pending navigation data load to be compared against\n// the globally incrementing load when a fetcher load lands after a completed\n// navigation\nlet pendingNavigationLoadId=-1;// Fetchers that triggered data reloads as a result of their actions\nlet fetchReloadIds=new Map();// Fetchers that triggered redirect navigations\nlet fetchRedirectIds=new Set();// Most recent href/match for fetcher.load calls for fetchers\nlet fetchLoadMatches=new Map();// Ref-count mounted fetchers so we know when it's ok to clean them up\nlet activeFetchers=new Map();// Fetchers that have requested a delete when using v7_fetcherPersist,\n// they'll be officially removed after they return to idle\nlet deletedFetchers=new Set();// Store DeferredData instances for active route matches.  When a\n// route loader returns defer() we stick one in here.  Then, when a nested\n// promise resolves we update loaderData.  If a new navigation starts we\n// cancel active deferreds for eliminated routes.\nlet activeDeferreds=new Map();// Store blocker functions in a separate Map outside of router state since\n// we don't need to update UI state if they change\nlet blockerFunctions=new Map();// Flag to ignore the next history update, so we can revert the URL change on\n// a POP navigation that was blocked by the user without touching router state\nlet ignoreNextHistoryUpdate=false;// Initialize the router, all side effects should be kicked off from here.\n// Implemented as a Fluent API for ease of:\n//   let router = createRouter(init).initialize();\nfunction initialize(){// If history informs us of a POP navigation, start the navigation but do not update\n// state.  We'll update our own state once the navigation completes\nunlistenHistory=init.history.listen(_ref=>{let{action:historyAction,location,delta}=_ref;// Ignore this event if it was just us resetting the URL from a\n// blocked POP navigation\nif(ignoreNextHistoryUpdate){ignoreNextHistoryUpdate=false;return;}warning(blockerFunctions.size===0||delta!=null,\"You are trying to use a blocker on a POP navigation to a location \"+\"that was not created by @remix-run/router. This will fail silently in \"+\"production. This can happen if you are navigating outside the router \"+\"via `window.history.pushState`/`window.location.hash` instead of using \"+\"router navigation APIs.  This can also happen if you are using \"+\"createHashRouter and the user manually changes the URL.\");let blockerKey=shouldBlockNavigation({currentLocation:state.location,nextLocation:location,historyAction});if(blockerKey&&delta!=null){// Restore the URL to match the current UI, but don't update router state\nignoreNextHistoryUpdate=true;init.history.go(delta*-1);// Put the blocker into a blocked state\nupdateBlocker(blockerKey,{state:\"blocked\",location,proceed(){updateBlocker(blockerKey,{state:\"proceeding\",proceed:undefined,reset:undefined,location});// Re-do the same POP navigation we just blocked\ninit.history.go(delta);},reset(){let blockers=new Map(state.blockers);blockers.set(blockerKey,IDLE_BLOCKER);updateState({blockers});}});return;}return startNavigation(historyAction,location);});if(isBrowser){// FIXME: This feels gross.  How can we cleanup the lines between\n// scrollRestoration/appliedTransitions persistance?\nrestoreAppliedTransitions(routerWindow,appliedViewTransitions);let _saveAppliedTransitions=()=>persistAppliedTransitions(routerWindow,appliedViewTransitions);routerWindow.addEventListener(\"pagehide\",_saveAppliedTransitions);removePageHideEventListener=()=>routerWindow.removeEventListener(\"pagehide\",_saveAppliedTransitions);}// Kick off initial data load if needed.  Use Pop to avoid modifying history\n// Note we don't do any handling of lazy here.  For SPA's it'll get handled\n// in the normal navigation flow.  For SSR it's expected that lazy modules are\n// resolved prior to router creation since we can't go into a fallbackElement\n// UI for SSR'd apps\nif(!state.initialized){startNavigation(Action.Pop,state.location);}return router;}// Clean up a router and it's side effects\nfunction dispose(){if(unlistenHistory){unlistenHistory();}if(removePageHideEventListener){removePageHideEventListener();}subscribers.clear();pendingNavigationController&&pendingNavigationController.abort();state.fetchers.forEach((_,key)=>deleteFetcher(key));state.blockers.forEach((_,key)=>deleteBlocker(key));}// Subscribe to state updates for the router\nfunction subscribe(fn){subscribers.add(fn);return()=>subscribers.delete(fn);}// Update our state and notify the calling context of the change\nfunction updateState(newState,opts){if(opts===void 0){opts={};}state=_extends({},state,newState);// Prep fetcher cleanup so we can tell the UI which fetcher data entries\n// can be removed\nlet completedFetchers=[];let deletedFetchersKeys=[];if(future.v7_fetcherPersist){state.fetchers.forEach((fetcher,key)=>{if(fetcher.state===\"idle\"){if(deletedFetchers.has(key)){// Unmounted from the UI and can be totally removed\ndeletedFetchersKeys.push(key);}else{// Returned to idle but still mounted in the UI, so semi-remains for\n// revalidations and such\ncompletedFetchers.push(key);}}});}// Iterate over a local copy so that if flushSync is used and we end up\n// removing and adding a new subscriber due to the useCallback dependencies,\n// we don't get ourselves into a loop calling the new subscriber immediately\n[...subscribers].forEach(subscriber=>subscriber(state,{deletedFetchers:deletedFetchersKeys,unstable_viewTransitionOpts:opts.viewTransitionOpts,unstable_flushSync:opts.flushSync===true}));// Remove idle fetchers from state since we only care about in-flight fetchers.\nif(future.v7_fetcherPersist){completedFetchers.forEach(key=>state.fetchers.delete(key));deletedFetchersKeys.forEach(key=>deleteFetcher(key));}}// Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n// and setting state.[historyAction/location/matches] to the new route.\n// - Location is a required param\n// - Navigation will always be set to IDLE_NAVIGATION\n// - Can pass any other state in newState\nfunction completeNavigation(location,newState,_temp){var _location$state,_location$state2;let{flushSync}=_temp===void 0?{}:_temp;// Deduce if we're in a loading/actionReload state:\n// - We have committed actionData in the store\n// - The current navigation was a mutation submission\n// - We're past the submitting state and into the loading state\n// - The location being loaded is not the result of a redirect\nlet isActionReload=state.actionData!=null&&state.navigation.formMethod!=null&&isMutationMethod(state.navigation.formMethod)&&state.navigation.state===\"loading\"&&((_location$state=location.state)==null?void 0:_location$state._isRedirect)!==true;let actionData;if(newState.actionData){if(Object.keys(newState.actionData).length>0){actionData=newState.actionData;}else{// Empty actionData -> clear prior actionData due to an action error\nactionData=null;}}else if(isActionReload){// Keep the current data if we're wrapping up the action reload\nactionData=state.actionData;}else{// Clear actionData on any other completed navigations\nactionData=null;}// Always preserve any existing loaderData from re-used routes\nlet loaderData=newState.loaderData?mergeLoaderData(state.loaderData,newState.loaderData,newState.matches||[],newState.errors):state.loaderData;// On a successful navigation we can assume we got through all blockers\n// so we can start fresh\nlet blockers=state.blockers;if(blockers.size>0){blockers=new Map(blockers);blockers.forEach((_,k)=>blockers.set(k,IDLE_BLOCKER));}// Always respect the user flag.  Otherwise don't reset on mutation\n// submission navigations unless they redirect\nlet preventScrollReset=pendingPreventScrollReset===true||state.navigation.formMethod!=null&&isMutationMethod(state.navigation.formMethod)&&((_location$state2=location.state)==null?void 0:_location$state2._isRedirect)!==true;if(inFlightDataRoutes){dataRoutes=inFlightDataRoutes;inFlightDataRoutes=undefined;}if(isUninterruptedRevalidation);else if(pendingAction===Action.Pop);else if(pendingAction===Action.Push){init.history.push(location,location.state);}else if(pendingAction===Action.Replace){init.history.replace(location,location.state);}let viewTransitionOpts;// On POP, enable transitions if they were enabled on the original navigation\nif(pendingAction===Action.Pop){// Forward takes precedence so they behave like the original navigation\nlet priorPaths=appliedViewTransitions.get(state.location.pathname);if(priorPaths&&priorPaths.has(location.pathname)){viewTransitionOpts={currentLocation:state.location,nextLocation:location};}else if(appliedViewTransitions.has(location.pathname)){// If we don't have a previous forward nav, assume we're popping back to\n// the new location and enable if that location previously enabled\nviewTransitionOpts={currentLocation:location,nextLocation:state.location};}}else if(pendingViewTransitionEnabled){// Store the applied transition on PUSH/REPLACE\nlet toPaths=appliedViewTransitions.get(state.location.pathname);if(toPaths){toPaths.add(location.pathname);}else{toPaths=new Set([location.pathname]);appliedViewTransitions.set(state.location.pathname,toPaths);}viewTransitionOpts={currentLocation:state.location,nextLocation:location};}updateState(_extends({},newState,{actionData,loaderData,historyAction:pendingAction,location,initialized:true,navigation:IDLE_NAVIGATION,revalidation:\"idle\",restoreScrollPosition:getSavedScrollPosition(location,newState.matches||state.matches),preventScrollReset,blockers}),{viewTransitionOpts,flushSync:flushSync===true});// Reset stateful navigation vars\npendingAction=Action.Pop;pendingPreventScrollReset=false;pendingViewTransitionEnabled=false;isUninterruptedRevalidation=false;isRevalidationRequired=false;cancelledDeferredRoutes=[];cancelledFetcherLoads=[];}// Trigger a navigation event, which can either be a numerical POP or a PUSH\n// replace with an optional submission\nasync function navigate(to,opts){if(typeof to===\"number\"){init.history.go(to);return;}let normalizedPath=normalizeTo(state.location,state.matches,basename,future.v7_prependBasename,to,opts==null?void 0:opts.fromRouteId,opts==null?void 0:opts.relative);let{path,submission,error}=normalizeNavigateOptions(future.v7_normalizeFormMethod,false,normalizedPath,opts);let currentLocation=state.location;let nextLocation=createLocation(state.location,path,opts&&opts.state);// When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n// URL from window.location, so we need to encode it here so the behavior\n// remains the same as POP and non-data-router usages.  new URL() does all\n// the same encoding we'd get from a history.pushState/window.location read\n// without having to touch history\nnextLocation=_extends({},nextLocation,init.history.encodeLocation(nextLocation));let userReplace=opts&&opts.replace!=null?opts.replace:undefined;let historyAction=Action.Push;if(userReplace===true){historyAction=Action.Replace;}else if(userReplace===false);else if(submission!=null&&isMutationMethod(submission.formMethod)&&submission.formAction===state.location.pathname+state.location.search){// By default on submissions to the current location we REPLACE so that\n// users don't have to double-click the back button to get to the prior\n// location.  If the user redirects to a different location from the\n// action/loader this will be ignored and the redirect will be a PUSH\nhistoryAction=Action.Replace;}let preventScrollReset=opts&&\"preventScrollReset\"in opts?opts.preventScrollReset===true:undefined;let flushSync=(opts&&opts.unstable_flushSync)===true;let blockerKey=shouldBlockNavigation({currentLocation,nextLocation,historyAction});if(blockerKey){// Put the blocker into a blocked state\nupdateBlocker(blockerKey,{state:\"blocked\",location:nextLocation,proceed(){updateBlocker(blockerKey,{state:\"proceeding\",proceed:undefined,reset:undefined,location:nextLocation});// Send the same navigation through\nnavigate(to,opts);},reset(){let blockers=new Map(state.blockers);blockers.set(blockerKey,IDLE_BLOCKER);updateState({blockers});}});return;}return await startNavigation(historyAction,nextLocation,{submission,// Send through the formData serialization error if we have one so we can\n// render at the right error boundary after we match routes\npendingError:error,preventScrollReset,replace:opts&&opts.replace,enableViewTransition:opts&&opts.unstable_viewTransition,flushSync});}// Revalidate all current loaders.  If a navigation is in progress or if this\n// is interrupted by a navigation, allow this to \"succeed\" by calling all\n// loaders during the next loader round\nfunction revalidate(){interruptActiveLoads();updateState({revalidation:\"loading\"});// If we're currently submitting an action, we don't need to start a new\n// navigation, we'll just let the follow up loader execution call all loaders\nif(state.navigation.state===\"submitting\"){return;}// If we're currently in an idle state, start a new navigation for the current\n// action/location and mark it as uninterrupted, which will skip the history\n// update in completeNavigation\nif(state.navigation.state===\"idle\"){startNavigation(state.historyAction,state.location,{startUninterruptedRevalidation:true});return;}// Otherwise, if we're currently in a loading state, just start a new\n// navigation to the navigation.location but do not trigger an uninterrupted\n// revalidation so that history correctly updates once the navigation completes\nstartNavigation(pendingAction||state.historyAction,state.navigation.location,{overrideNavigation:state.navigation});}// Start a navigation to the given action/location.  Can optionally provide a\n// overrideNavigation which will override the normalLoad in the case of a redirect\n// navigation\nasync function startNavigation(historyAction,location,opts){// Abort any in-progress navigations and start a new one. Unset any ongoing\n// uninterrupted revalidations unless told otherwise, since we want this\n// new navigation to update history normally\npendingNavigationController&&pendingNavigationController.abort();pendingNavigationController=null;pendingAction=historyAction;isUninterruptedRevalidation=(opts&&opts.startUninterruptedRevalidation)===true;// Save the current scroll position every time we start a new navigation,\n// and track whether we should reset scroll on completion\nsaveScrollPosition(state.location,state.matches);pendingPreventScrollReset=(opts&&opts.preventScrollReset)===true;pendingViewTransitionEnabled=(opts&&opts.enableViewTransition)===true;let routesToUse=inFlightDataRoutes||dataRoutes;let loadingNavigation=opts&&opts.overrideNavigation;let matches=matchRoutes(routesToUse,location,basename);let flushSync=(opts&&opts.flushSync)===true;// Short circuit with a 404 on the root error boundary if we match nothing\nif(!matches){let error=getInternalRouterError(404,{pathname:location.pathname});let{matches:notFoundMatches,route}=getShortCircuitMatches(routesToUse);// Cancel all pending deferred on 404s since we don't keep any routes\ncancelActiveDeferreds();completeNavigation(location,{matches:notFoundMatches,loaderData:{},errors:{[route.id]:error}},{flushSync});return;}// Short circuit if it's only a hash change and not a revalidation or\n// mutation submission.\n//\n// Ignore on initial page loads because since the initial load will always\n// be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n// which will default to a navigation to /page\nif(state.initialized&&!isRevalidationRequired&&isHashChangeOnly(state.location,location)&&!(opts&&opts.submission&&isMutationMethod(opts.submission.formMethod))){completeNavigation(location,{matches},{flushSync});return;}// Create a controller/Request for this navigation\npendingNavigationController=new AbortController();let request=createClientSideRequest(init.history,location,pendingNavigationController.signal,opts&&opts.submission);let pendingActionData;let pendingError;if(opts&&opts.pendingError){// If we have a pendingError, it means the user attempted a GET submission\n// with binary FormData so assign here and skip to handleLoaders.  That\n// way we handle calling loaders above the boundary etc.  It's not really\n// different from an actionError in that sense.\npendingError={[findNearestBoundary(matches).route.id]:opts.pendingError};}else if(opts&&opts.submission&&isMutationMethod(opts.submission.formMethod)){// Call action if we received an action submission\nlet actionOutput=await handleAction(request,location,opts.submission,matches,{replace:opts.replace,flushSync});if(actionOutput.shortCircuited){return;}pendingActionData=actionOutput.pendingActionData;pendingError=actionOutput.pendingActionError;loadingNavigation=getLoadingNavigation(location,opts.submission);flushSync=false;// Create a GET request for the loaders\nrequest=new Request(request.url,{signal:request.signal});}// Call loaders\nlet{shortCircuited,loaderData,errors}=await handleLoaders(request,location,matches,loadingNavigation,opts&&opts.submission,opts&&opts.fetcherSubmission,opts&&opts.replace,flushSync,pendingActionData,pendingError);if(shortCircuited){return;}// Clean up now that the action/loaders have completed.  Don't clean up if\n// we short circuited because pendingNavigationController will have already\n// been assigned to a new controller for the next navigation\npendingNavigationController=null;completeNavigation(location,_extends({matches},pendingActionData?{actionData:pendingActionData}:{},{loaderData,errors}));}// Call the action matched by the leaf route for this navigation and handle\n// redirects/errors\nasync function handleAction(request,location,submission,matches,opts){if(opts===void 0){opts={};}interruptActiveLoads();// Put us in a submitting state\nlet navigation=getSubmittingNavigation(location,submission);updateState({navigation},{flushSync:opts.flushSync===true});// Call our action and get the result\nlet result;let actionMatch=getTargetMatch(matches,location);if(!actionMatch.route.action&&!actionMatch.route.lazy){result={type:ResultType.error,error:getInternalRouterError(405,{method:request.method,pathname:location.pathname,routeId:actionMatch.route.id})};}else{result=await callLoaderOrAction(\"action\",request,actionMatch,matches,manifest,mapRouteProperties,basename);if(request.signal.aborted){return{shortCircuited:true};}}if(isRedirectResult(result)){let replace;if(opts&&opts.replace!=null){replace=opts.replace;}else{// If the user didn't explicity indicate replace behavior, replace if\n// we redirected to the exact same location we're currently at to avoid\n// double back-buttons\nreplace=result.location===state.location.pathname+state.location.search;}await startRedirectNavigation(state,result,{submission,replace});return{shortCircuited:true};}if(isErrorResult(result)){// Store off the pending error - we use it to determine which loaders\n// to call and will commit it when we complete the navigation\nlet boundaryMatch=findNearestBoundary(matches,actionMatch.route.id);// By default, all submissions are REPLACE navigations, but if the\n// action threw an error that'll be rendered in an errorElement, we fall\n// back to PUSH so that the user can use the back button to get back to\n// the pre-submission form location to try again\nif((opts&&opts.replace)!==true){pendingAction=Action.Push;}return{// Send back an empty object we can use to clear out any prior actionData\npendingActionData:{},pendingActionError:{[boundaryMatch.route.id]:result.error}};}if(isDeferredResult(result)){throw getInternalRouterError(400,{type:\"defer-action\"});}return{pendingActionData:{[actionMatch.route.id]:result.data}};}// Call all applicable loaders for the given matches, handling redirects,\n// errors, etc.\nasync function handleLoaders(request,location,matches,overrideNavigation,submission,fetcherSubmission,replace,flushSync,pendingActionData,pendingError){// Figure out the right navigation we want to use for data loading\nlet loadingNavigation=overrideNavigation||getLoadingNavigation(location,submission);// If this was a redirect from an action we don't have a \"submission\" but\n// we have it on the loading navigation so use that if available\nlet activeSubmission=submission||fetcherSubmission||getSubmissionFromNavigation(loadingNavigation);let routesToUse=inFlightDataRoutes||dataRoutes;let[matchesToLoad,revalidatingFetchers]=getMatchesToLoad(init.history,state,matches,activeSubmission,location,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,deletedFetchers,fetchLoadMatches,fetchRedirectIds,routesToUse,basename,pendingActionData,pendingError);// Cancel pending deferreds for no-longer-matched routes or routes we're\n// about to reload.  Note that if this is an action reload we would have\n// already cancelled all pending deferreds so this would be a no-op\ncancelActiveDeferreds(routeId=>!(matches&&matches.some(m=>m.route.id===routeId))||matchesToLoad&&matchesToLoad.some(m=>m.route.id===routeId));pendingNavigationLoadId=++incrementingLoadId;// Short circuit if we have no loaders to run\nif(matchesToLoad.length===0&&revalidatingFetchers.length===0){let updatedFetchers=markFetchRedirectsDone();completeNavigation(location,_extends({matches,loaderData:{},// Commit pending error if we're short circuiting\nerrors:pendingError||null},pendingActionData?{actionData:pendingActionData}:{},updatedFetchers?{fetchers:new Map(state.fetchers)}:{}),{flushSync});return{shortCircuited:true};}// If this is an uninterrupted revalidation, we remain in our current idle\n// state.  If not, we need to switch to our loading state and load data,\n// preserving any new action data or existing action data (in the case of\n// a revalidation interrupting an actionReload)\nif(!isUninterruptedRevalidation){revalidatingFetchers.forEach(rf=>{let fetcher=state.fetchers.get(rf.key);let revalidatingFetcher=getLoadingFetcher(undefined,fetcher?fetcher.data:undefined);state.fetchers.set(rf.key,revalidatingFetcher);});let actionData=pendingActionData||state.actionData;updateState(_extends({navigation:loadingNavigation},actionData?Object.keys(actionData).length===0?{actionData:null}:{actionData}:{},revalidatingFetchers.length>0?{fetchers:new Map(state.fetchers)}:{}),{flushSync});}revalidatingFetchers.forEach(rf=>{if(fetchControllers.has(rf.key)){abortFetcher(rf.key);}if(rf.controller){// Fetchers use an independent AbortController so that aborting a fetcher\n// (via deleteFetcher) does not abort the triggering navigation that\n// triggered the revalidation\nfetchControllers.set(rf.key,rf.controller);}});// Proxy navigation abort through to revalidation fetchers\nlet abortPendingFetchRevalidations=()=>revalidatingFetchers.forEach(f=>abortFetcher(f.key));if(pendingNavigationController){pendingNavigationController.signal.addEventListener(\"abort\",abortPendingFetchRevalidations);}let{results,loaderResults,fetcherResults}=await callLoadersAndMaybeResolveData(state.matches,matches,matchesToLoad,revalidatingFetchers,request);if(request.signal.aborted){return{shortCircuited:true};}// Clean up _after_ loaders have completed.  Don't clean up if we short\n// circuited because fetchControllers would have been aborted and\n// reassigned to new controllers for the next navigation\nif(pendingNavigationController){pendingNavigationController.signal.removeEventListener(\"abort\",abortPendingFetchRevalidations);}revalidatingFetchers.forEach(rf=>fetchControllers.delete(rf.key));// If any loaders returned a redirect Response, start a new REPLACE navigation\nlet redirect=findRedirect(results);if(redirect){if(redirect.idx>=matchesToLoad.length){// If this redirect came from a fetcher make sure we mark it in\n// fetchRedirectIds so it doesn't get revalidated on the next set of\n// loader executions\nlet fetcherKey=revalidatingFetchers[redirect.idx-matchesToLoad.length].key;fetchRedirectIds.add(fetcherKey);}await startRedirectNavigation(state,redirect.result,{replace});return{shortCircuited:true};}// Process and commit output from loaders\nlet{loaderData,errors}=processLoaderData(state,matches,matchesToLoad,loaderResults,pendingError,revalidatingFetchers,fetcherResults,activeDeferreds);// Wire up subscribers to update loaderData as promises settle\nactiveDeferreds.forEach((deferredData,routeId)=>{deferredData.subscribe(aborted=>{// Note: No need to updateState here since the TrackedPromise on\n// loaderData is stable across resolve/reject\n// Remove this instance if we were aborted or if promises have settled\nif(aborted||deferredData.done){activeDeferreds.delete(routeId);}});});let updatedFetchers=markFetchRedirectsDone();let didAbortFetchLoads=abortStaleFetchLoads(pendingNavigationLoadId);let shouldUpdateFetchers=updatedFetchers||didAbortFetchLoads||revalidatingFetchers.length>0;return _extends({loaderData,errors},shouldUpdateFetchers?{fetchers:new Map(state.fetchers)}:{});}// Trigger a fetcher load/submit for the given fetcher key\nfunction fetch(key,routeId,href,opts){if(isServer){throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \"+\"You are likely calling a useFetcher() method in the body of your component. \"+\"Try moving it to a useEffect or a callback.\");}if(fetchControllers.has(key))abortFetcher(key);let flushSync=(opts&&opts.unstable_flushSync)===true;let routesToUse=inFlightDataRoutes||dataRoutes;let normalizedPath=normalizeTo(state.location,state.matches,basename,future.v7_prependBasename,href,routeId,opts==null?void 0:opts.relative);let matches=matchRoutes(routesToUse,normalizedPath,basename);if(!matches){setFetcherError(key,routeId,getInternalRouterError(404,{pathname:normalizedPath}),{flushSync});return;}let{path,submission,error}=normalizeNavigateOptions(future.v7_normalizeFormMethod,true,normalizedPath,opts);if(error){setFetcherError(key,routeId,error,{flushSync});return;}let match=getTargetMatch(matches,path);pendingPreventScrollReset=(opts&&opts.preventScrollReset)===true;if(submission&&isMutationMethod(submission.formMethod)){handleFetcherAction(key,routeId,path,match,matches,flushSync,submission);return;}// Store off the match so we can call it's shouldRevalidate on subsequent\n// revalidations\nfetchLoadMatches.set(key,{routeId,path});handleFetcherLoader(key,routeId,path,match,matches,flushSync,submission);}// Call the action for the matched fetcher.submit(), and then handle redirects,\n// errors, and revalidation\nasync function handleFetcherAction(key,routeId,path,match,requestMatches,flushSync,submission){interruptActiveLoads();fetchLoadMatches.delete(key);if(!match.route.action&&!match.route.lazy){let error=getInternalRouterError(405,{method:submission.formMethod,pathname:path,routeId:routeId});setFetcherError(key,routeId,error,{flushSync});return;}// Put this fetcher into it's submitting state\nlet existingFetcher=state.fetchers.get(key);updateFetcherState(key,getSubmittingFetcher(submission,existingFetcher),{flushSync});// Call the action for the fetcher\nlet abortController=new AbortController();let fetchRequest=createClientSideRequest(init.history,path,abortController.signal,submission);fetchControllers.set(key,abortController);let originatingLoadId=incrementingLoadId;let actionResult=await callLoaderOrAction(\"action\",fetchRequest,match,requestMatches,manifest,mapRouteProperties,basename);if(fetchRequest.signal.aborted){// We can delete this so long as we weren't aborted by our own fetcher\n// re-submit which would have put _new_ controller is in fetchControllers\nif(fetchControllers.get(key)===abortController){fetchControllers.delete(key);}return;}if(deletedFetchers.has(key)){updateFetcherState(key,getDoneFetcher(undefined));return;}if(isRedirectResult(actionResult)){fetchControllers.delete(key);if(pendingNavigationLoadId>originatingLoadId){// A new navigation was kicked off after our action started, so that\n// should take precedence over this redirect navigation.  We already\n// set isRevalidationRequired so all loaders for the new route should\n// fire unless opted out via shouldRevalidate\nupdateFetcherState(key,getDoneFetcher(undefined));return;}else{fetchRedirectIds.add(key);updateFetcherState(key,getLoadingFetcher(submission));return startRedirectNavigation(state,actionResult,{fetcherSubmission:submission});}}// Process any non-redirect errors thrown\nif(isErrorResult(actionResult)){setFetcherError(key,routeId,actionResult.error);return;}if(isDeferredResult(actionResult)){throw getInternalRouterError(400,{type:\"defer-action\"});}// Start the data load for current matches, or the next location if we're\n// in the middle of a navigation\nlet nextLocation=state.navigation.location||state.location;let revalidationRequest=createClientSideRequest(init.history,nextLocation,abortController.signal);let routesToUse=inFlightDataRoutes||dataRoutes;let matches=state.navigation.state!==\"idle\"?matchRoutes(routesToUse,state.navigation.location,basename):state.matches;invariant(matches,\"Didn't find any matches after fetcher action\");let loadId=++incrementingLoadId;fetchReloadIds.set(key,loadId);let loadFetcher=getLoadingFetcher(submission,actionResult.data);state.fetchers.set(key,loadFetcher);let[matchesToLoad,revalidatingFetchers]=getMatchesToLoad(init.history,state,matches,submission,nextLocation,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,deletedFetchers,fetchLoadMatches,fetchRedirectIds,routesToUse,basename,{[match.route.id]:actionResult.data},undefined// No need to send through errors since we short circuit above\n);// Put all revalidating fetchers into the loading state, except for the\n// current fetcher which we want to keep in it's current loading state which\n// contains it's action submission info + action data\nrevalidatingFetchers.filter(rf=>rf.key!==key).forEach(rf=>{let staleKey=rf.key;let existingFetcher=state.fetchers.get(staleKey);let revalidatingFetcher=getLoadingFetcher(undefined,existingFetcher?existingFetcher.data:undefined);state.fetchers.set(staleKey,revalidatingFetcher);if(fetchControllers.has(staleKey)){abortFetcher(staleKey);}if(rf.controller){fetchControllers.set(staleKey,rf.controller);}});updateState({fetchers:new Map(state.fetchers)});let abortPendingFetchRevalidations=()=>revalidatingFetchers.forEach(rf=>abortFetcher(rf.key));abortController.signal.addEventListener(\"abort\",abortPendingFetchRevalidations);let{results,loaderResults,fetcherResults}=await callLoadersAndMaybeResolveData(state.matches,matches,matchesToLoad,revalidatingFetchers,revalidationRequest);if(abortController.signal.aborted){return;}abortController.signal.removeEventListener(\"abort\",abortPendingFetchRevalidations);fetchReloadIds.delete(key);fetchControllers.delete(key);revalidatingFetchers.forEach(r=>fetchControllers.delete(r.key));let redirect=findRedirect(results);if(redirect){if(redirect.idx>=matchesToLoad.length){// If this redirect came from a fetcher make sure we mark it in\n// fetchRedirectIds so it doesn't get revalidated on the next set of\n// loader executions\nlet fetcherKey=revalidatingFetchers[redirect.idx-matchesToLoad.length].key;fetchRedirectIds.add(fetcherKey);}return startRedirectNavigation(state,redirect.result);}// Process and commit output from loaders\nlet{loaderData,errors}=processLoaderData(state,state.matches,matchesToLoad,loaderResults,undefined,revalidatingFetchers,fetcherResults,activeDeferreds);// Since we let revalidations complete even if the submitting fetcher was\n// deleted, only put it back to idle if it hasn't been deleted\nif(state.fetchers.has(key)){let doneFetcher=getDoneFetcher(actionResult.data);state.fetchers.set(key,doneFetcher);}abortStaleFetchLoads(loadId);// If we are currently in a navigation loading state and this fetcher is\n// more recent than the navigation, we want the newer data so abort the\n// navigation and complete it with the fetcher data\nif(state.navigation.state===\"loading\"&&loadId>pendingNavigationLoadId){invariant(pendingAction,\"Expected pending action\");pendingNavigationController&&pendingNavigationController.abort();completeNavigation(state.navigation.location,{matches,loaderData,errors,fetchers:new Map(state.fetchers)});}else{// otherwise just update with the fetcher data, preserving any existing\n// loaderData for loaders that did not need to reload.  We have to\n// manually merge here since we aren't going through completeNavigation\nupdateState({errors,loaderData:mergeLoaderData(state.loaderData,loaderData,matches,errors),fetchers:new Map(state.fetchers)});isRevalidationRequired=false;}}// Call the matched loader for fetcher.load(), handling redirects, errors, etc.\nasync function handleFetcherLoader(key,routeId,path,match,matches,flushSync,submission){let existingFetcher=state.fetchers.get(key);updateFetcherState(key,getLoadingFetcher(submission,existingFetcher?existingFetcher.data:undefined),{flushSync});// Call the loader for this fetcher route match\nlet abortController=new AbortController();let fetchRequest=createClientSideRequest(init.history,path,abortController.signal);fetchControllers.set(key,abortController);let originatingLoadId=incrementingLoadId;let result=await callLoaderOrAction(\"loader\",fetchRequest,match,matches,manifest,mapRouteProperties,basename);// Deferred isn't supported for fetcher loads, await everything and treat it\n// as a normal load.  resolveDeferredData will return undefined if this\n// fetcher gets aborted, so we just leave result untouched and short circuit\n// below if that happens\nif(isDeferredResult(result)){result=(await resolveDeferredData(result,fetchRequest.signal,true))||result;}// We can delete this so long as we weren't aborted by our our own fetcher\n// re-load which would have put _new_ controller is in fetchControllers\nif(fetchControllers.get(key)===abortController){fetchControllers.delete(key);}if(fetchRequest.signal.aborted){return;}if(deletedFetchers.has(key)){updateFetcherState(key,getDoneFetcher(undefined));return;}// If the loader threw a redirect Response, start a new REPLACE navigation\nif(isRedirectResult(result)){if(pendingNavigationLoadId>originatingLoadId){// A new navigation was kicked off after our loader started, so that\n// should take precedence over this redirect navigation\nupdateFetcherState(key,getDoneFetcher(undefined));return;}else{fetchRedirectIds.add(key);await startRedirectNavigation(state,result);return;}}// Process any non-redirect errors thrown\nif(isErrorResult(result)){setFetcherError(key,routeId,result.error);return;}invariant(!isDeferredResult(result),\"Unhandled fetcher deferred data\");// Put the fetcher back into an idle state\nupdateFetcherState(key,getDoneFetcher(result.data));}/**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */async function startRedirectNavigation(state,redirect,_temp2){let{submission,fetcherSubmission,replace}=_temp2===void 0?{}:_temp2;if(redirect.revalidate){isRevalidationRequired=true;}let redirectLocation=createLocation(state.location,redirect.location,{_isRedirect:true});invariant(redirectLocation,\"Expected a location on the redirect navigation\");if(isBrowser){let isDocumentReload=false;if(redirect.reloadDocument){// Hard reload if the response contained X-Remix-Reload-Document\nisDocumentReload=true;}else if(ABSOLUTE_URL_REGEX.test(redirect.location)){const url=init.history.createURL(redirect.location);isDocumentReload=// Hard reload if it's an absolute URL to a new origin\nurl.origin!==routerWindow.location.origin||// Hard reload if it's an absolute URL that does not match our basename\nstripBasename(url.pathname,basename)==null;}if(isDocumentReload){if(replace){routerWindow.location.replace(redirect.location);}else{routerWindow.location.assign(redirect.location);}return;}}// There's no need to abort on redirects, since we don't detect the\n// redirect until the action/loaders have settled\npendingNavigationController=null;let redirectHistoryAction=replace===true?Action.Replace:Action.Push;// Use the incoming submission if provided, fallback on the active one in\n// state.navigation\nlet{formMethod,formAction,formEncType}=state.navigation;if(!submission&&!fetcherSubmission&&formMethod&&formAction&&formEncType){submission=getSubmissionFromNavigation(state.navigation);}// If this was a 307/308 submission we want to preserve the HTTP method and\n// re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n// redirected location\nlet activeSubmission=submission||fetcherSubmission;if(redirectPreserveMethodStatusCodes.has(redirect.status)&&activeSubmission&&isMutationMethod(activeSubmission.formMethod)){await startNavigation(redirectHistoryAction,redirectLocation,{submission:_extends({},activeSubmission,{formAction:redirect.location}),// Preserve this flag across redirects\npreventScrollReset:pendingPreventScrollReset});}else{// If we have a navigation submission, we will preserve it through the\n// redirect navigation\nlet overrideNavigation=getLoadingNavigation(redirectLocation,submission);await startNavigation(redirectHistoryAction,redirectLocation,{overrideNavigation,// Send fetcher submissions through for shouldRevalidate\nfetcherSubmission,// Preserve this flag across redirects\npreventScrollReset:pendingPreventScrollReset});}}async function callLoadersAndMaybeResolveData(currentMatches,matches,matchesToLoad,fetchersToLoad,request){// Call all navigation loaders and revalidating fetcher loaders in parallel,\n// then slice off the results into separate arrays so we can handle them\n// accordingly\nlet results=await Promise.all([...matchesToLoad.map(match=>callLoaderOrAction(\"loader\",request,match,matches,manifest,mapRouteProperties,basename)),...fetchersToLoad.map(f=>{if(f.matches&&f.match&&f.controller){return callLoaderOrAction(\"loader\",createClientSideRequest(init.history,f.path,f.controller.signal),f.match,f.matches,manifest,mapRouteProperties,basename);}else{let error={type:ResultType.error,error:getInternalRouterError(404,{pathname:f.path})};return error;}})]);let loaderResults=results.slice(0,matchesToLoad.length);let fetcherResults=results.slice(matchesToLoad.length);await Promise.all([resolveDeferredResults(currentMatches,matchesToLoad,loaderResults,loaderResults.map(()=>request.signal),false,state.loaderData),resolveDeferredResults(currentMatches,fetchersToLoad.map(f=>f.match),fetcherResults,fetchersToLoad.map(f=>f.controller?f.controller.signal:null),true)]);return{results,loaderResults,fetcherResults};}function interruptActiveLoads(){// Every interruption triggers a revalidation\nisRevalidationRequired=true;// Cancel pending route-level deferreds and mark cancelled routes for\n// revalidation\ncancelledDeferredRoutes.push(...cancelActiveDeferreds());// Abort in-flight fetcher loads\nfetchLoadMatches.forEach((_,key)=>{if(fetchControllers.has(key)){cancelledFetcherLoads.push(key);abortFetcher(key);}});}function updateFetcherState(key,fetcher,opts){if(opts===void 0){opts={};}state.fetchers.set(key,fetcher);updateState({fetchers:new Map(state.fetchers)},{flushSync:(opts&&opts.flushSync)===true});}function setFetcherError(key,routeId,error,opts){if(opts===void 0){opts={};}let boundaryMatch=findNearestBoundary(state.matches,routeId);deleteFetcher(key);updateState({errors:{[boundaryMatch.route.id]:error},fetchers:new Map(state.fetchers)},{flushSync:(opts&&opts.flushSync)===true});}function getFetcher(key){if(future.v7_fetcherPersist){activeFetchers.set(key,(activeFetchers.get(key)||0)+1);// If this fetcher was previously marked for deletion, unmark it since we\n// have a new instance\nif(deletedFetchers.has(key)){deletedFetchers.delete(key);}}return state.fetchers.get(key)||IDLE_FETCHER;}function deleteFetcher(key){let fetcher=state.fetchers.get(key);// Don't abort the controller if this is a deletion of a fetcher.submit()\n// in it's loading phase since - we don't want to abort the corresponding\n// revalidation and want them to complete and land\nif(fetchControllers.has(key)&&!(fetcher&&fetcher.state===\"loading\"&&fetchReloadIds.has(key))){abortFetcher(key);}fetchLoadMatches.delete(key);fetchReloadIds.delete(key);fetchRedirectIds.delete(key);deletedFetchers.delete(key);state.fetchers.delete(key);}function deleteFetcherAndUpdateState(key){if(future.v7_fetcherPersist){let count=(activeFetchers.get(key)||0)-1;if(count<=0){activeFetchers.delete(key);deletedFetchers.add(key);}else{activeFetchers.set(key,count);}}else{deleteFetcher(key);}updateState({fetchers:new Map(state.fetchers)});}function abortFetcher(key){let controller=fetchControllers.get(key);invariant(controller,\"Expected fetch controller: \"+key);controller.abort();fetchControllers.delete(key);}function markFetchersDone(keys){for(let key of keys){let fetcher=getFetcher(key);let doneFetcher=getDoneFetcher(fetcher.data);state.fetchers.set(key,doneFetcher);}}function markFetchRedirectsDone(){let doneKeys=[];let updatedFetchers=false;for(let key of fetchRedirectIds){let fetcher=state.fetchers.get(key);invariant(fetcher,\"Expected fetcher: \"+key);if(fetcher.state===\"loading\"){fetchRedirectIds.delete(key);doneKeys.push(key);updatedFetchers=true;}}markFetchersDone(doneKeys);return updatedFetchers;}function abortStaleFetchLoads(landedId){let yeetedKeys=[];for(let[key,id]of fetchReloadIds){if(id<landedId){let fetcher=state.fetchers.get(key);invariant(fetcher,\"Expected fetcher: \"+key);if(fetcher.state===\"loading\"){abortFetcher(key);fetchReloadIds.delete(key);yeetedKeys.push(key);}}}markFetchersDone(yeetedKeys);return yeetedKeys.length>0;}function getBlocker(key,fn){let blocker=state.blockers.get(key)||IDLE_BLOCKER;if(blockerFunctions.get(key)!==fn){blockerFunctions.set(key,fn);}return blocker;}function deleteBlocker(key){state.blockers.delete(key);blockerFunctions.delete(key);}// Utility function to update blockers, ensuring valid state transitions\nfunction updateBlocker(key,newBlocker){let blocker=state.blockers.get(key)||IDLE_BLOCKER;// Poor mans state machine :)\n// https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\ninvariant(blocker.state===\"unblocked\"&&newBlocker.state===\"blocked\"||blocker.state===\"blocked\"&&newBlocker.state===\"blocked\"||blocker.state===\"blocked\"&&newBlocker.state===\"proceeding\"||blocker.state===\"blocked\"&&newBlocker.state===\"unblocked\"||blocker.state===\"proceeding\"&&newBlocker.state===\"unblocked\",\"Invalid blocker state transition: \"+blocker.state+\" -> \"+newBlocker.state);let blockers=new Map(state.blockers);blockers.set(key,newBlocker);updateState({blockers});}function shouldBlockNavigation(_ref2){let{currentLocation,nextLocation,historyAction}=_ref2;if(blockerFunctions.size===0){return;}// We ony support a single active blocker at the moment since we don't have\n// any compelling use cases for multi-blocker yet\nif(blockerFunctions.size>1){warning(false,\"A router only supports one blocker at a time\");}let entries=Array.from(blockerFunctions.entries());let[blockerKey,blockerFunction]=entries[entries.length-1];let blocker=state.blockers.get(blockerKey);if(blocker&&blocker.state===\"proceeding\"){// If the blocker is currently proceeding, we don't need to re-check\n// it and can let this navigation continue\nreturn;}// At this point, we know we're unblocked/blocked so we need to check the\n// user-provided blocker function\nif(blockerFunction({currentLocation,nextLocation,historyAction})){return blockerKey;}}function cancelActiveDeferreds(predicate){let cancelledRouteIds=[];activeDeferreds.forEach((dfd,routeId)=>{if(!predicate||predicate(routeId)){// Cancel the deferred - but do not remove from activeDeferreds here -\n// we rely on the subscribers to do that so our tests can assert proper\n// cleanup via _internalActiveDeferreds\ndfd.cancel();cancelledRouteIds.push(routeId);activeDeferreds.delete(routeId);}});return cancelledRouteIds;}// Opt in to capturing and reporting scroll positions during navigations,\n// used by the <ScrollRestoration> component\nfunction enableScrollRestoration(positions,getPosition,getKey){savedScrollPositions=positions;getScrollPosition=getPosition;getScrollRestorationKey=getKey||null;// Perform initial hydration scroll restoration, since we miss the boat on\n// the initial updateState() because we've not yet rendered <ScrollRestoration/>\n// and therefore have no savedScrollPositions available\nif(!initialScrollRestored&&state.navigation===IDLE_NAVIGATION){initialScrollRestored=true;let y=getSavedScrollPosition(state.location,state.matches);if(y!=null){updateState({restoreScrollPosition:y});}}return()=>{savedScrollPositions=null;getScrollPosition=null;getScrollRestorationKey=null;};}function getScrollKey(location,matches){if(getScrollRestorationKey){let key=getScrollRestorationKey(location,matches.map(m=>convertRouteMatchToUiMatch(m,state.loaderData)));return key||location.key;}return location.key;}function saveScrollPosition(location,matches){if(savedScrollPositions&&getScrollPosition){let key=getScrollKey(location,matches);savedScrollPositions[key]=getScrollPosition();}}function getSavedScrollPosition(location,matches){if(savedScrollPositions){let key=getScrollKey(location,matches);let y=savedScrollPositions[key];if(typeof y===\"number\"){return y;}}return null;}function _internalSetRoutes(newRoutes){manifest={};inFlightDataRoutes=convertRoutesToDataRoutes(newRoutes,mapRouteProperties,undefined,manifest);}router={get basename(){return basename;},get state(){return state;},get routes(){return dataRoutes;},get window(){return routerWindow;},initialize,subscribe,enableScrollRestoration,navigate,fetch,revalidate,// Passthrough to history-aware createHref used by useHref so we get proper\n// hash-aware URLs in DOM paths\ncreateHref:to=>init.history.createHref(to),encodeLocation:to=>init.history.encodeLocation(to),getFetcher,deleteFetcher:deleteFetcherAndUpdateState,dispose,getBlocker,deleteBlocker,_internalFetchControllers:fetchControllers,_internalActiveDeferreds:activeDeferreds,// TODO: Remove setRoutes, it's temporary to avoid dealing with\n// updating the tree while validating the update algorithm.\n_internalSetRoutes};return router;}//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL=Symbol(\"deferred\");function createStaticHandler(routes,opts){invariant(routes.length>0,\"You must provide a non-empty routes array to createStaticHandler\");let manifest={};let basename=(opts?opts.basename:null)||\"/\";let mapRouteProperties;if(opts!=null&&opts.mapRouteProperties){mapRouteProperties=opts.mapRouteProperties;}else if(opts!=null&&opts.detectErrorBoundary){// If they are still using the deprecated version, wrap it with the new API\nlet detectErrorBoundary=opts.detectErrorBoundary;mapRouteProperties=route=>({hasErrorBoundary:detectErrorBoundary(route)});}else{mapRouteProperties=defaultMapRouteProperties;}let dataRoutes=convertRoutesToDataRoutes(routes,mapRouteProperties,undefined,manifest);/**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */async function query(request,_temp3){let{requestContext}=_temp3===void 0?{}:_temp3;let url=new URL(request.url);let method=request.method;let location=createLocation(\"\",createPath(url),null,\"default\");let matches=matchRoutes(dataRoutes,location,basename);// SSR supports HEAD requests while SPA doesn't\nif(!isValidMethod(method)&&method!==\"HEAD\"){let error=getInternalRouterError(405,{method});let{matches:methodNotAllowedMatches,route}=getShortCircuitMatches(dataRoutes);return{basename,location,matches:methodNotAllowedMatches,loaderData:{},actionData:null,errors:{[route.id]:error},statusCode:error.status,loaderHeaders:{},actionHeaders:{},activeDeferreds:null};}else if(!matches){let error=getInternalRouterError(404,{pathname:location.pathname});let{matches:notFoundMatches,route}=getShortCircuitMatches(dataRoutes);return{basename,location,matches:notFoundMatches,loaderData:{},actionData:null,errors:{[route.id]:error},statusCode:error.status,loaderHeaders:{},actionHeaders:{},activeDeferreds:null};}let result=await queryImpl(request,location,matches,requestContext);if(isResponse(result)){return result;}// When returning StaticHandlerContext, we patch back in the location here\n// since we need it for React Context.  But this helps keep our submit and\n// loadRouteData operating on a Request instead of a Location\nreturn _extends({location,basename},result);}/**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */async function queryRoute(request,_temp4){let{routeId,requestContext}=_temp4===void 0?{}:_temp4;let url=new URL(request.url);let method=request.method;let location=createLocation(\"\",createPath(url),null,\"default\");let matches=matchRoutes(dataRoutes,location,basename);// SSR supports HEAD requests while SPA doesn't\nif(!isValidMethod(method)&&method!==\"HEAD\"&&method!==\"OPTIONS\"){throw getInternalRouterError(405,{method});}else if(!matches){throw getInternalRouterError(404,{pathname:location.pathname});}let match=routeId?matches.find(m=>m.route.id===routeId):getTargetMatch(matches,location);if(routeId&&!match){throw getInternalRouterError(403,{pathname:location.pathname,routeId});}else if(!match){// This should never hit I don't think?\nthrow getInternalRouterError(404,{pathname:location.pathname});}let result=await queryImpl(request,location,matches,requestContext,match);if(isResponse(result)){return result;}let error=result.errors?Object.values(result.errors)[0]:undefined;if(error!==undefined){// If we got back result.errors, that means the loader/action threw\n// _something_ that wasn't a Response, but it's not guaranteed/required\n// to be an `instanceof Error` either, so we have to use throw here to\n// preserve the \"error\" state outside of queryImpl.\nthrow error;}// Pick off the right state value to return\nif(result.actionData){return Object.values(result.actionData)[0];}if(result.loaderData){var _result$activeDeferre;let data=Object.values(result.loaderData)[0];if((_result$activeDeferre=result.activeDeferreds)!=null&&_result$activeDeferre[match.route.id]){data[UNSAFE_DEFERRED_SYMBOL]=result.activeDeferreds[match.route.id];}return data;}return undefined;}async function queryImpl(request,location,matches,requestContext,routeMatch){invariant(request.signal,\"query()/queryRoute() requests must contain an AbortController signal\");try{if(isMutationMethod(request.method.toLowerCase())){let result=await submit(request,matches,routeMatch||getTargetMatch(matches,location),requestContext,routeMatch!=null);return result;}let result=await loadRouteData(request,matches,requestContext,routeMatch);return isResponse(result)?result:_extends({},result,{actionData:null,actionHeaders:{}});}catch(e){// If the user threw/returned a Response in callLoaderOrAction, we throw\n// it to bail out and then return or throw here based on whether the user\n// returned or threw\nif(isQueryRouteResponse(e)){if(e.type===ResultType.error){throw e.response;}return e.response;}// Redirects are always returned since they don't propagate to catch\n// boundaries\nif(isRedirectResponse(e)){return e;}throw e;}}async function submit(request,matches,actionMatch,requestContext,isRouteRequest){let result;if(!actionMatch.route.action&&!actionMatch.route.lazy){let error=getInternalRouterError(405,{method:request.method,pathname:new URL(request.url).pathname,routeId:actionMatch.route.id});if(isRouteRequest){throw error;}result={type:ResultType.error,error};}else{result=await callLoaderOrAction(\"action\",request,actionMatch,matches,manifest,mapRouteProperties,basename,{isStaticRequest:true,isRouteRequest,requestContext});if(request.signal.aborted){let method=isRouteRequest?\"queryRoute\":\"query\";throw new Error(method+\"() call aborted: \"+request.method+\" \"+request.url);}}if(isRedirectResult(result)){// Uhhhh - this should never happen, we should always throw these from\n// callLoaderOrAction, but the type narrowing here keeps TS happy and we\n// can get back on the \"throw all redirect responses\" train here should\n// this ever happen :/\nthrow new Response(null,{status:result.status,headers:{Location:result.location}});}if(isDeferredResult(result)){let error=getInternalRouterError(400,{type:\"defer-action\"});if(isRouteRequest){throw error;}result={type:ResultType.error,error};}if(isRouteRequest){// Note: This should only be non-Response values if we get here, since\n// isRouteRequest should throw any Response received in callLoaderOrAction\nif(isErrorResult(result)){throw result.error;}return{matches:[actionMatch],loaderData:{},actionData:{[actionMatch.route.id]:result.data},errors:null,// Note: statusCode + headers are unused here since queryRoute will\n// return the raw Response or value\nstatusCode:200,loaderHeaders:{},actionHeaders:{},activeDeferreds:null};}if(isErrorResult(result)){// Store off the pending error - we use it to determine which loaders\n// to call and will commit it when we complete the navigation\nlet boundaryMatch=findNearestBoundary(matches,actionMatch.route.id);let context=await loadRouteData(request,matches,requestContext,undefined,{[boundaryMatch.route.id]:result.error});// action status codes take precedence over loader status codes\nreturn _extends({},context,{statusCode:isRouteErrorResponse(result.error)?result.error.status:500,actionData:null,actionHeaders:_extends({},result.headers?{[actionMatch.route.id]:result.headers}:{})});}// Create a GET request for the loaders\nlet loaderRequest=new Request(request.url,{headers:request.headers,redirect:request.redirect,signal:request.signal});let context=await loadRouteData(loaderRequest,matches,requestContext);return _extends({},context,result.statusCode?{statusCode:result.statusCode}:{},{actionData:{[actionMatch.route.id]:result.data},actionHeaders:_extends({},result.headers?{[actionMatch.route.id]:result.headers}:{})});}async function loadRouteData(request,matches,requestContext,routeMatch,pendingActionError){let isRouteRequest=routeMatch!=null;// Short circuit if we have no loaders to run (queryRoute())\nif(isRouteRequest&&!(routeMatch!=null&&routeMatch.route.loader)&&!(routeMatch!=null&&routeMatch.route.lazy)){throw getInternalRouterError(400,{method:request.method,pathname:new URL(request.url).pathname,routeId:routeMatch==null?void 0:routeMatch.route.id});}let requestMatches=routeMatch?[routeMatch]:getLoaderMatchesUntilBoundary(matches,Object.keys(pendingActionError||{})[0]);let matchesToLoad=requestMatches.filter(m=>m.route.loader||m.route.lazy);// Short circuit if we have no loaders to run (query())\nif(matchesToLoad.length===0){return{matches,// Add a null for all matched routes for proper revalidation on the client\nloaderData:matches.reduce((acc,m)=>Object.assign(acc,{[m.route.id]:null}),{}),errors:pendingActionError||null,statusCode:200,loaderHeaders:{},activeDeferreds:null};}let results=await Promise.all([...matchesToLoad.map(match=>callLoaderOrAction(\"loader\",request,match,matches,manifest,mapRouteProperties,basename,{isStaticRequest:true,isRouteRequest,requestContext}))]);if(request.signal.aborted){let method=isRouteRequest?\"queryRoute\":\"query\";throw new Error(method+\"() call aborted: \"+request.method+\" \"+request.url);}// Process and commit output from loaders\nlet activeDeferreds=new Map();let context=processRouteLoaderData(matches,matchesToLoad,results,pendingActionError,activeDeferreds);// Add a null for any non-loader matches for proper revalidation on the client\nlet executedLoaders=new Set(matchesToLoad.map(match=>match.route.id));matches.forEach(match=>{if(!executedLoaders.has(match.route.id)){context.loaderData[match.route.id]=null;}});return _extends({},context,{matches,activeDeferreds:activeDeferreds.size>0?Object.fromEntries(activeDeferreds.entries()):null});}return{dataRoutes,query,queryRoute};}//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */function getStaticContextFromError(routes,context,error){let newContext=_extends({},context,{statusCode:500,errors:{[context._deepestRenderedBoundaryId||routes[0].id]:error}});return newContext;}function isSubmissionNavigation(opts){return opts!=null&&(\"formData\"in opts&&opts.formData!=null||\"body\"in opts&&opts.body!==undefined);}function normalizeTo(location,matches,basename,prependBasename,to,fromRouteId,relative){let contextualMatches;let activeRouteMatch;if(fromRouteId){// Grab matches up to the calling route so our route-relative logic is\n// relative to the correct source route\ncontextualMatches=[];for(let match of matches){contextualMatches.push(match);if(match.route.id===fromRouteId){activeRouteMatch=match;break;}}}else{contextualMatches=matches;activeRouteMatch=matches[matches.length-1];}// Resolve the relative path\nlet path=resolveTo(to?to:\".\",getPathContributingMatches(contextualMatches).map(m=>m.pathnameBase),stripBasename(location.pathname,basename)||location.pathname,relative===\"path\");// When `to` is not specified we inherit search/hash from the current\n// location, unlike when to=\".\" and we just inherit the path.\n// See https://github.com/remix-run/remix/issues/927\nif(to==null){path.search=location.search;path.hash=location.hash;}// Add an ?index param for matched index routes if we don't already have one\nif((to==null||to===\"\"||to===\".\")&&activeRouteMatch&&activeRouteMatch.route.index&&!hasNakedIndexQuery(path.search)){path.search=path.search?path.search.replace(/^\\?/,\"?index&\"):\"?index\";}// If we're operating within a basename, prepend it to the pathname.  If\n// this is a root navigation, then just use the raw basename which allows\n// the basename to have full control over the presence of a trailing slash\n// on root actions\nif(prependBasename&&basename!==\"/\"){path.pathname=path.pathname===\"/\"?basename:joinPaths([basename,path.pathname]);}return createPath(path);}// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod,isFetcher,path,opts){// Return location verbatim on non-submission navigations\nif(!opts||!isSubmissionNavigation(opts)){return{path};}if(opts.formMethod&&!isValidMethod(opts.formMethod)){return{path,error:getInternalRouterError(405,{method:opts.formMethod})};}let getInvalidBodyError=()=>({path,error:getInternalRouterError(400,{type:\"invalid-body\"})});// Create a Submission on non-GET navigations\nlet rawFormMethod=opts.formMethod||\"get\";let formMethod=normalizeFormMethod?rawFormMethod.toUpperCase():rawFormMethod.toLowerCase();let formAction=stripHashFromPath(path);if(opts.body!==undefined){if(opts.formEncType===\"text/plain\"){// text only support POST/PUT/PATCH/DELETE submissions\nif(!isMutationMethod(formMethod)){return getInvalidBodyError();}let text=typeof opts.body===\"string\"?opts.body:opts.body instanceof FormData||opts.body instanceof URLSearchParams?// https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\nArray.from(opts.body.entries()).reduce((acc,_ref3)=>{let[name,value]=_ref3;return\"\"+acc+name+\"=\"+value+\"\\n\";},\"\"):String(opts.body);return{path,submission:{formMethod,formAction,formEncType:opts.formEncType,formData:undefined,json:undefined,text}};}else if(opts.formEncType===\"application/json\"){// json only supports POST/PUT/PATCH/DELETE submissions\nif(!isMutationMethod(formMethod)){return getInvalidBodyError();}try{let json=typeof opts.body===\"string\"?JSON.parse(opts.body):opts.body;return{path,submission:{formMethod,formAction,formEncType:opts.formEncType,formData:undefined,json,text:undefined}};}catch(e){return getInvalidBodyError();}}}invariant(typeof FormData===\"function\",\"FormData is not available in this environment\");let searchParams;let formData;if(opts.formData){searchParams=convertFormDataToSearchParams(opts.formData);formData=opts.formData;}else if(opts.body instanceof FormData){searchParams=convertFormDataToSearchParams(opts.body);formData=opts.body;}else if(opts.body instanceof URLSearchParams){searchParams=opts.body;formData=convertSearchParamsToFormData(searchParams);}else if(opts.body==null){searchParams=new URLSearchParams();formData=new FormData();}else{try{searchParams=new URLSearchParams(opts.body);formData=convertSearchParamsToFormData(searchParams);}catch(e){return getInvalidBodyError();}}let submission={formMethod,formAction,formEncType:opts&&opts.formEncType||\"application/x-www-form-urlencoded\",formData,json:undefined,text:undefined};if(isMutationMethod(submission.formMethod)){return{path,submission};}// Flatten submission onto URLSearchParams for GET submissions\nlet parsedPath=parsePath(path);// On GET navigation submissions we can drop the ?index param from the\n// resulting location since all loaders will run.  But fetcher GET submissions\n// only run a single loader so we need to preserve any incoming ?index params\nif(isFetcher&&parsedPath.search&&hasNakedIndexQuery(parsedPath.search)){searchParams.append(\"index\",\"\");}parsedPath.search=\"?\"+searchParams;return{path:createPath(parsedPath),submission};}// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches,boundaryId){let boundaryMatches=matches;if(boundaryId){let index=matches.findIndex(m=>m.route.id===boundaryId);if(index>=0){boundaryMatches=matches.slice(0,index);}}return boundaryMatches;}function getMatchesToLoad(history,state,matches,submission,location,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,deletedFetchers,fetchLoadMatches,fetchRedirectIds,routesToUse,basename,pendingActionData,pendingError){let actionResult=pendingError?Object.values(pendingError)[0]:pendingActionData?Object.values(pendingActionData)[0]:undefined;let currentUrl=history.createURL(state.location);let nextUrl=history.createURL(location);// Pick navigation matches that are net-new or qualify for revalidation\nlet boundaryId=pendingError?Object.keys(pendingError)[0]:undefined;let boundaryMatches=getLoaderMatchesUntilBoundary(matches,boundaryId);let navigationMatches=boundaryMatches.filter((match,index)=>{if(match.route.lazy){// We haven't loaded this route yet so we don't know if it's got a loader!\nreturn true;}if(match.route.loader==null){return false;}// Always call the loader on new route instances and pending defer cancellations\nif(isNewLoader(state.loaderData,state.matches[index],match)||cancelledDeferredRoutes.some(id=>id===match.route.id)){return true;}// This is the default implementation for when we revalidate.  If the route\n// provides it's own implementation, then we give them full control but\n// provide this value so they can leverage it if needed after they check\n// their own specific use cases\nlet currentRouteMatch=state.matches[index];let nextRouteMatch=match;return shouldRevalidateLoader(match,_extends({currentUrl,currentParams:currentRouteMatch.params,nextUrl,nextParams:nextRouteMatch.params},submission,{actionResult,defaultShouldRevalidate:// Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\nisRevalidationRequired||// Clicked the same link, resubmitted a GET form\ncurrentUrl.pathname+currentUrl.search===nextUrl.pathname+nextUrl.search||// Search params affect all loaders\ncurrentUrl.search!==nextUrl.search||isNewRouteInstance(currentRouteMatch,nextRouteMatch)}));});// Pick fetcher.loads that need to be revalidated\nlet revalidatingFetchers=[];fetchLoadMatches.forEach((f,key)=>{// Don't revalidate if fetcher won't be present in the subsequent render\nif(!matches.some(m=>m.route.id===f.routeId)||deletedFetchers.has(key)){return;}let fetcherMatches=matchRoutes(routesToUse,f.path,basename);// If the fetcher path no longer matches, push it in with null matches so\n// we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n// currently only a use-case for Remix HMR where the route tree can change\n// at runtime and remove a route previously loaded via a fetcher\nif(!fetcherMatches){revalidatingFetchers.push({key,routeId:f.routeId,path:f.path,matches:null,match:null,controller:null});return;}// Revalidating fetchers are decoupled from the route matches since they\n// load from a static href.  They revalidate based on explicit revalidation\n// (submission, useRevalidator, or X-Remix-Revalidate)\nlet fetcher=state.fetchers.get(key);let fetcherMatch=getTargetMatch(fetcherMatches,f.path);let shouldRevalidate=false;if(fetchRedirectIds.has(key)){// Never trigger a revalidation of an actively redirecting fetcher\nshouldRevalidate=false;}else if(cancelledFetcherLoads.includes(key)){// Always revalidate if the fetcher was cancelled\nshouldRevalidate=true;}else if(fetcher&&fetcher.state!==\"idle\"&&fetcher.data===undefined){// If the fetcher hasn't ever completed loading yet, then this isn't a\n// revalidation, it would just be a brand new load if an explicit\n// revalidation is required\nshouldRevalidate=isRevalidationRequired;}else{// Otherwise fall back on any user-defined shouldRevalidate, defaulting\n// to explicit revalidations only\nshouldRevalidate=shouldRevalidateLoader(fetcherMatch,_extends({currentUrl,currentParams:state.matches[state.matches.length-1].params,nextUrl,nextParams:matches[matches.length-1].params},submission,{actionResult,defaultShouldRevalidate:isRevalidationRequired}));}if(shouldRevalidate){revalidatingFetchers.push({key,routeId:f.routeId,path:f.path,matches:fetcherMatches,match:fetcherMatch,controller:new AbortController()});}});return[navigationMatches,revalidatingFetchers];}function isNewLoader(currentLoaderData,currentMatch,match){let isNew=// [a] -> [a, b]\n!currentMatch||// [a, b] -> [a, c]\nmatch.route.id!==currentMatch.route.id;// Handle the case that we don't have data for a re-used route, potentially\n// from a prior error or from a cancelled pending deferred\nlet isMissingData=currentLoaderData[match.route.id]===undefined;// Always load if this is a net-new route or we don't yet have data\nreturn isNew||isMissingData;}function isNewRouteInstance(currentMatch,match){let currentPath=currentMatch.route.path;return(// param change for this match, /users/123 -> /users/456\ncurrentMatch.pathname!==match.pathname||// splat param changed, which is not present in match.path\n// e.g. /files/images/avatar.jpg -> files/finances.xls\ncurrentPath!=null&&currentPath.endsWith(\"*\")&&currentMatch.params[\"*\"]!==match.params[\"*\"]);}function shouldRevalidateLoader(loaderMatch,arg){if(loaderMatch.route.shouldRevalidate){let routeChoice=loaderMatch.route.shouldRevalidate(arg);if(typeof routeChoice===\"boolean\"){return routeChoice;}}return arg.defaultShouldRevalidate;}/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */async function loadLazyRouteModule(route,mapRouteProperties,manifest){if(!route.lazy){return;}let lazyRoute=await route.lazy();// If the lazy route function was executed and removed by another parallel\n// call then we can return - first lazy() to finish wins because the return\n// value of lazy is expected to be static\nif(!route.lazy){return;}let routeToUpdate=manifest[route.id];invariant(routeToUpdate,\"No route found in manifest\");// Update the route in place.  This should be safe because there's no way\n// we could yet be sitting on this route as we can't get there without\n// resolving lazy() first.\n//\n// This is different than the HMR \"update\" use-case where we may actively be\n// on the route being updated.  The main concern boils down to \"does this\n// mutation affect any ongoing navigations or any current state.matches\n// values?\".  If not, it should be safe to update in place.\nlet routeUpdates={};for(let lazyRouteProperty in lazyRoute){let staticRouteValue=routeToUpdate[lazyRouteProperty];let isPropertyStaticallyDefined=staticRouteValue!==undefined&&// This property isn't static since it should always be updated based\n// on the route updates\nlazyRouteProperty!==\"hasErrorBoundary\";warning(!isPropertyStaticallyDefined,\"Route \\\"\"+routeToUpdate.id+\"\\\" has a static property \\\"\"+lazyRouteProperty+\"\\\" \"+\"defined but its lazy function is also returning a value for this property. \"+(\"The lazy route property \\\"\"+lazyRouteProperty+\"\\\" will be ignored.\"));if(!isPropertyStaticallyDefined&&!immutableRouteKeys.has(lazyRouteProperty)){routeUpdates[lazyRouteProperty]=lazyRoute[lazyRouteProperty];}}// Mutate the route with the provided updates.  Do this first so we pass\n// the updated version to mapRouteProperties\nObject.assign(routeToUpdate,routeUpdates);// Mutate the `hasErrorBoundary` property on the route based on the route\n// updates and remove the `lazy` function so we don't resolve the lazy\n// route again.\nObject.assign(routeToUpdate,_extends({},mapRouteProperties(routeToUpdate),{lazy:undefined}));}async function callLoaderOrAction(type,request,match,matches,manifest,mapRouteProperties,basename,opts){if(opts===void 0){opts={};}let resultType;let result;let onReject;let runHandler=handler=>{// Setup a promise we can race against so that abort signals short circuit\nlet reject;let abortPromise=new Promise((_,r)=>reject=r);onReject=()=>reject();request.signal.addEventListener(\"abort\",onReject);return Promise.race([handler({request,params:match.params,context:opts.requestContext}),abortPromise]);};try{let handler=match.route[type];if(match.route.lazy){if(handler){// Run statically defined handler in parallel with lazy()\nlet handlerError;let values=await Promise.all([// If the handler throws, don't let it immediately bubble out,\n// since we need to let the lazy() execution finish so we know if this\n// route has a boundary that can handle the error\nrunHandler(handler).catch(e=>{handlerError=e;}),loadLazyRouteModule(match.route,mapRouteProperties,manifest)]);if(handlerError){throw handlerError;}result=values[0];}else{// Load lazy route module, then run any returned handler\nawait loadLazyRouteModule(match.route,mapRouteProperties,manifest);handler=match.route[type];if(handler){// Handler still run even if we got interrupted to maintain consistency\n// with un-abortable behavior of handler execution on non-lazy or\n// previously-lazy-loaded routes\nresult=await runHandler(handler);}else if(type===\"action\"){let url=new URL(request.url);let pathname=url.pathname+url.search;throw getInternalRouterError(405,{method:request.method,pathname,routeId:match.route.id});}else{// lazy() route has no loader to run.  Short circuit here so we don't\n// hit the invariant below that errors on returning undefined.\nreturn{type:ResultType.data,data:undefined};}}}else if(!handler){let url=new URL(request.url);let pathname=url.pathname+url.search;throw getInternalRouterError(404,{pathname});}else{result=await runHandler(handler);}invariant(result!==undefined,\"You defined \"+(type===\"action\"?\"an action\":\"a loader\")+\" for route \"+(\"\\\"\"+match.route.id+\"\\\" but didn't return anything from your `\"+type+\"` \")+\"function. Please return a value or `null`.\");}catch(e){resultType=ResultType.error;result=e;}finally{if(onReject){request.signal.removeEventListener(\"abort\",onReject);}}if(isResponse(result)){let status=result.status;// Process redirects\nif(redirectStatusCodes.has(status)){let location=result.headers.get(\"Location\");invariant(location,\"Redirects returned/thrown from loaders/actions must have a Location header\");// Support relative routing in internal redirects\nif(!ABSOLUTE_URL_REGEX.test(location)){location=normalizeTo(new URL(request.url),matches.slice(0,matches.indexOf(match)+1),basename,true,location);}else if(!opts.isStaticRequest){// Strip off the protocol+origin for same-origin + same-basename absolute\n// redirects. If this is a static request, we can let it go back to the\n// browser as-is\nlet currentUrl=new URL(request.url);let url=location.startsWith(\"//\")?new URL(currentUrl.protocol+location):new URL(location);let isSameBasename=stripBasename(url.pathname,basename)!=null;if(url.origin===currentUrl.origin&&isSameBasename){location=url.pathname+url.search+url.hash;}}// Don't process redirects in the router during static requests requests.\n// Instead, throw the Response and let the server handle it with an HTTP\n// redirect.  We also update the Location header in place in this flow so\n// basename and relative routing is taken into account\nif(opts.isStaticRequest){result.headers.set(\"Location\",location);throw result;}return{type:ResultType.redirect,status,location,revalidate:result.headers.get(\"X-Remix-Revalidate\")!==null,reloadDocument:result.headers.get(\"X-Remix-Reload-Document\")!==null};}// For SSR single-route requests, we want to hand Responses back directly\n// without unwrapping.  We do this with the QueryRouteResponse wrapper\n// interface so we can know whether it was returned or thrown\nif(opts.isRouteRequest){let queryRouteResponse={type:resultType===ResultType.error?ResultType.error:ResultType.data,response:result};throw queryRouteResponse;}let data;let contentType=result.headers.get(\"Content-Type\");// Check between word boundaries instead of startsWith() due to the last\n// paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\nif(contentType&&/\\bapplication\\/json\\b/.test(contentType)){data=await result.json();}else{data=await result.text();}if(resultType===ResultType.error){return{type:resultType,error:new ErrorResponseImpl(status,result.statusText,data),headers:result.headers};}return{type:ResultType.data,data,statusCode:result.status,headers:result.headers};}if(resultType===ResultType.error){return{type:resultType,error:result};}if(isDeferredData(result)){var _result$init,_result$init2;return{type:ResultType.deferred,deferredData:result,statusCode:(_result$init=result.init)==null?void 0:_result$init.status,headers:((_result$init2=result.init)==null?void 0:_result$init2.headers)&&new Headers(result.init.headers)};}return{type:ResultType.data,data:result};}// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history,location,signal,submission){let url=history.createURL(stripHashFromPath(location)).toString();let init={signal};if(submission&&isMutationMethod(submission.formMethod)){let{formMethod,formEncType}=submission;// Didn't think we needed this but it turns out unlike other methods, patch\n// won't be properly normalized to uppercase and results in a 405 error.\n// See: https://fetch.spec.whatwg.org/#concept-method\ninit.method=formMethod.toUpperCase();if(formEncType===\"application/json\"){init.headers=new Headers({\"Content-Type\":formEncType});init.body=JSON.stringify(submission.json);}else if(formEncType===\"text/plain\"){// Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\ninit.body=submission.text;}else if(formEncType===\"application/x-www-form-urlencoded\"&&submission.formData){// Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\ninit.body=convertFormDataToSearchParams(submission.formData);}else{// Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\ninit.body=submission.formData;}}return new Request(url,init);}function convertFormDataToSearchParams(formData){let searchParams=new URLSearchParams();for(let[key,value]of formData.entries()){// https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\nsearchParams.append(key,typeof value===\"string\"?value:value.name);}return searchParams;}function convertSearchParamsToFormData(searchParams){let formData=new FormData();for(let[key,value]of searchParams.entries()){formData.append(key,value);}return formData;}function processRouteLoaderData(matches,matchesToLoad,results,pendingError,activeDeferreds){// Fill in loaderData/errors from our loaders\nlet loaderData={};let errors=null;let statusCode;let foundError=false;let loaderHeaders={};// Process loader results into state.loaderData/state.errors\nresults.forEach((result,index)=>{let id=matchesToLoad[index].route.id;invariant(!isRedirectResult(result),\"Cannot handle redirect results in processLoaderData\");if(isErrorResult(result)){// Look upwards from the matched route for the closest ancestor\n// error boundary, defaulting to the root match\nlet boundaryMatch=findNearestBoundary(matches,id);let error=result.error;// If we have a pending action error, we report it at the highest-route\n// that throws a loader error, and then clear it out to indicate that\n// it was consumed\nif(pendingError){error=Object.values(pendingError)[0];pendingError=undefined;}errors=errors||{};// Prefer higher error values if lower errors bubble to the same boundary\nif(errors[boundaryMatch.route.id]==null){errors[boundaryMatch.route.id]=error;}// Clear our any prior loaderData for the throwing route\nloaderData[id]=undefined;// Once we find our first (highest) error, we set the status code and\n// prevent deeper status codes from overriding\nif(!foundError){foundError=true;statusCode=isRouteErrorResponse(result.error)?result.error.status:500;}if(result.headers){loaderHeaders[id]=result.headers;}}else{if(isDeferredResult(result)){activeDeferreds.set(id,result.deferredData);loaderData[id]=result.deferredData.data;}else{loaderData[id]=result.data;}// Error status codes always override success status codes, but if all\n// loaders are successful we take the deepest status code.\nif(result.statusCode!=null&&result.statusCode!==200&&!foundError){statusCode=result.statusCode;}if(result.headers){loaderHeaders[id]=result.headers;}}});// If we didn't consume the pending action error (i.e., all loaders\n// resolved), then consume it here.  Also clear out any loaderData for the\n// throwing route\nif(pendingError){errors=pendingError;loaderData[Object.keys(pendingError)[0]]=undefined;}return{loaderData,errors,statusCode:statusCode||200,loaderHeaders};}function processLoaderData(state,matches,matchesToLoad,results,pendingError,revalidatingFetchers,fetcherResults,activeDeferreds){let{loaderData,errors}=processRouteLoaderData(matches,matchesToLoad,results,pendingError,activeDeferreds);// Process results from our revalidating fetchers\nfor(let index=0;index<revalidatingFetchers.length;index++){let{key,match,controller}=revalidatingFetchers[index];invariant(fetcherResults!==undefined&&fetcherResults[index]!==undefined,\"Did not find corresponding fetcher result\");let result=fetcherResults[index];// Process fetcher non-redirect errors\nif(controller&&controller.signal.aborted){// Nothing to do for aborted fetchers\ncontinue;}else if(isErrorResult(result)){let boundaryMatch=findNearestBoundary(state.matches,match==null?void 0:match.route.id);if(!(errors&&errors[boundaryMatch.route.id])){errors=_extends({},errors,{[boundaryMatch.route.id]:result.error});}state.fetchers.delete(key);}else if(isRedirectResult(result)){// Should never get here, redirects should get processed above, but we\n// keep this to type narrow to a success result in the else\ninvariant(false,\"Unhandled fetcher revalidation redirect\");}else if(isDeferredResult(result)){// Should never get here, deferred data should be awaited for fetchers\n// in resolveDeferredResults\ninvariant(false,\"Unhandled fetcher deferred data\");}else{let doneFetcher=getDoneFetcher(result.data);state.fetchers.set(key,doneFetcher);}}return{loaderData,errors};}function mergeLoaderData(loaderData,newLoaderData,matches,errors){let mergedLoaderData=_extends({},newLoaderData);for(let match of matches){let id=match.route.id;if(newLoaderData.hasOwnProperty(id)){if(newLoaderData[id]!==undefined){mergedLoaderData[id]=newLoaderData[id];}}else if(loaderData[id]!==undefined&&match.route.loader){// Preserve existing keys not included in newLoaderData and where a loader\n// wasn't removed by HMR\nmergedLoaderData[id]=loaderData[id];}if(errors&&errors.hasOwnProperty(id)){// Don't keep any loader data below the boundary\nbreak;}}return mergedLoaderData;}// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches,routeId){let eligibleMatches=routeId?matches.slice(0,matches.findIndex(m=>m.route.id===routeId)+1):[...matches];return eligibleMatches.reverse().find(m=>m.route.hasErrorBoundary===true)||matches[0];}function getShortCircuitMatches(routes){// Prefer a root layout route if present, otherwise shim in a route object\nlet route=routes.length===1?routes[0]:routes.find(r=>r.index||!r.path||r.path===\"/\")||{id:\"__shim-error-route__\"};return{matches:[{params:{},pathname:\"\",pathnameBase:\"\",route}],route};}function getInternalRouterError(status,_temp5){let{pathname,routeId,method,type}=_temp5===void 0?{}:_temp5;let statusText=\"Unknown Server Error\";let errorMessage=\"Unknown @remix-run/router error\";if(status===400){statusText=\"Bad Request\";if(method&&pathname&&routeId){errorMessage=\"You made a \"+method+\" request to \\\"\"+pathname+\"\\\" but \"+(\"did not provide a `loader` for route \\\"\"+routeId+\"\\\", \")+\"so there is no way to handle the request.\";}else if(type===\"defer-action\"){errorMessage=\"defer() is not supported in actions\";}else if(type===\"invalid-body\"){errorMessage=\"Unable to encode submission body\";}}else if(status===403){statusText=\"Forbidden\";errorMessage=\"Route \\\"\"+routeId+\"\\\" does not match URL \\\"\"+pathname+\"\\\"\";}else if(status===404){statusText=\"Not Found\";errorMessage=\"No route matches URL \\\"\"+pathname+\"\\\"\";}else if(status===405){statusText=\"Method Not Allowed\";if(method&&pathname&&routeId){errorMessage=\"You made a \"+method.toUpperCase()+\" request to \\\"\"+pathname+\"\\\" but \"+(\"did not provide an `action` for route \\\"\"+routeId+\"\\\", \")+\"so there is no way to handle the request.\";}else if(method){errorMessage=\"Invalid request method \\\"\"+method.toUpperCase()+\"\\\"\";}}return new ErrorResponseImpl(status||500,statusText,new Error(errorMessage),true);}// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results){for(let i=results.length-1;i>=0;i--){let result=results[i];if(isRedirectResult(result)){return{result,idx:i};}}}function stripHashFromPath(path){let parsedPath=typeof path===\"string\"?parsePath(path):path;return createPath(_extends({},parsedPath,{hash:\"\"}));}function isHashChangeOnly(a,b){if(a.pathname!==b.pathname||a.search!==b.search){return false;}if(a.hash===\"\"){// /page -> /page#hash\nreturn b.hash!==\"\";}else if(a.hash===b.hash){// /page#hash -> /page#hash\nreturn true;}else if(b.hash!==\"\"){// /page#hash -> /page#other\nreturn true;}// If the hash is removed the browser will re-perform a request to the server\n// /page#hash -> /page\nreturn false;}function isDeferredResult(result){return result.type===ResultType.deferred;}function isErrorResult(result){return result.type===ResultType.error;}function isRedirectResult(result){return(result&&result.type)===ResultType.redirect;}function isDeferredData(value){let deferred=value;return deferred&&typeof deferred===\"object\"&&typeof deferred.data===\"object\"&&typeof deferred.subscribe===\"function\"&&typeof deferred.cancel===\"function\"&&typeof deferred.resolveData===\"function\";}function isResponse(value){return value!=null&&typeof value.status===\"number\"&&typeof value.statusText===\"string\"&&typeof value.headers===\"object\"&&typeof value.body!==\"undefined\";}function isRedirectResponse(result){if(!isResponse(result)){return false;}let status=result.status;let location=result.headers.get(\"Location\");return status>=300&&status<=399&&location!=null;}function isQueryRouteResponse(obj){return obj&&isResponse(obj.response)&&(obj.type===ResultType.data||obj.type===ResultType.error);}function isValidMethod(method){return validRequestMethods.has(method.toLowerCase());}function isMutationMethod(method){return validMutationMethods.has(method.toLowerCase());}async function resolveDeferredResults(currentMatches,matchesToLoad,results,signals,isFetcher,currentLoaderData){for(let index=0;index<results.length;index++){let result=results[index];let match=matchesToLoad[index];// If we don't have a match, then we can have a deferred result to do\n// anything with.  This is for revalidating fetchers where the route was\n// removed during HMR\nif(!match){continue;}let currentMatch=currentMatches.find(m=>m.route.id===match.route.id);let isRevalidatingLoader=currentMatch!=null&&!isNewRouteInstance(currentMatch,match)&&(currentLoaderData&&currentLoaderData[match.route.id])!==undefined;if(isDeferredResult(result)&&(isFetcher||isRevalidatingLoader)){// Note: we do not have to touch activeDeferreds here since we race them\n// against the signal in resolveDeferredData and they'll get aborted\n// there if needed\nlet signal=signals[index];invariant(signal,\"Expected an AbortSignal for revalidating fetcher deferred result\");await resolveDeferredData(result,signal,isFetcher).then(result=>{if(result){results[index]=result||results[index];}});}}}async function resolveDeferredData(result,signal,unwrap){if(unwrap===void 0){unwrap=false;}let aborted=await result.deferredData.resolveData(signal);if(aborted){return;}if(unwrap){try{return{type:ResultType.data,data:result.deferredData.unwrappedData};}catch(e){// Handle any TrackedPromise._error values encountered while unwrapping\nreturn{type:ResultType.error,error:e};}}return{type:ResultType.data,data:result.deferredData.data};}function hasNakedIndexQuery(search){return new URLSearchParams(search).getAll(\"index\").some(v=>v===\"\");}function getTargetMatch(matches,location){let search=typeof location===\"string\"?parsePath(location).search:location.search;if(matches[matches.length-1].route.index&&hasNakedIndexQuery(search||\"\")){// Return the leaf index route when index is present\nreturn matches[matches.length-1];}// Otherwise grab the deepest \"path contributing\" match (ignoring index and\n// pathless layout routes)\nlet pathMatches=getPathContributingMatches(matches);return pathMatches[pathMatches.length-1];}function getSubmissionFromNavigation(navigation){let{formMethod,formAction,formEncType,text,formData,json}=navigation;if(!formMethod||!formAction||!formEncType){return;}if(text!=null){return{formMethod,formAction,formEncType,formData:undefined,json:undefined,text};}else if(formData!=null){return{formMethod,formAction,formEncType,formData,json:undefined,text:undefined};}else if(json!==undefined){return{formMethod,formAction,formEncType,formData:undefined,json,text:undefined};}}function getLoadingNavigation(location,submission){if(submission){let navigation={state:\"loading\",location,formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text};return navigation;}else{let navigation={state:\"loading\",location,formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined};return navigation;}}function getSubmittingNavigation(location,submission){let navigation={state:\"submitting\",location,formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text};return navigation;}function getLoadingFetcher(submission,data){if(submission){let fetcher={state:\"loading\",formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text,data};return fetcher;}else{let fetcher={state:\"loading\",formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined,data};return fetcher;}}function getSubmittingFetcher(submission,existingFetcher){let fetcher={state:\"submitting\",formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text,data:existingFetcher?existingFetcher.data:undefined};return fetcher;}function getDoneFetcher(data){let fetcher={state:\"idle\",formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined,data};return fetcher;}function restoreAppliedTransitions(_window,transitions){try{let sessionPositions=_window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);if(sessionPositions){let json=JSON.parse(sessionPositions);for(let[k,v]of Object.entries(json||{})){if(v&&Array.isArray(v)){transitions.set(k,new Set(v||[]));}}}}catch(e){// no-op, use default empty object\n}}function persistAppliedTransitions(_window,transitions){if(transitions.size>0){let json={};for(let[k,v]of transitions){json[k]=[...v];}try{_window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY,JSON.stringify(json));}catch(error){warning(false,\"Failed to save applied view transitions in sessionStorage (\"+error+\").\");}}}//#endregion\nexport{AbortedDeferredError,Action,IDLE_BLOCKER,IDLE_FETCHER,IDLE_NAVIGATION,UNSAFE_DEFERRED_SYMBOL,DeferredData as UNSAFE_DeferredData,ErrorResponseImpl as UNSAFE_ErrorResponseImpl,convertRouteMatchToUiMatch as UNSAFE_convertRouteMatchToUiMatch,convertRoutesToDataRoutes as UNSAFE_convertRoutesToDataRoutes,getPathContributingMatches as UNSAFE_getPathContributingMatches,invariant as UNSAFE_invariant,warning as UNSAFE_warning,createBrowserHistory,createHashHistory,createMemoryHistory,createPath,createRouter,createStaticHandler,defer,generatePath,getStaticContextFromError,getToPathname,isDeferredData,isRouteErrorResponse,joinPaths,json,matchPath,matchRoutes,normalizePathname,parsePath,redirect,redirectDocument,resolvePath,resolveTo,stripBasename};"],"sourceRoot":""}